<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>第2章　Java内存区域与内存溢出异常 - YZLC</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="YZLC"><meta name=description content="2.2 运行时数据区域 2.2.1 程序计数器（Program Counter Register） 字节码的行号指示器，程序控制流的指示器（分支、循环、跳转、异常处理、线程恢复"><meta name=keywords content="yzlc"><meta name=generator content="Hugo 0.110.0 with theme even"><link rel=canonical href=https://yzlc.github.io/post/read/jvm/2/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<link href=/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><link rel=stylesheet href=/css/dark.css><link rel=stylesheet href=/css/custom.css><meta property="og:title" content="第2章　Java内存区域与内存溢出异常"><meta property="og:description" content="2.2 运行时数据区域 2.2.1 程序计数器（Program Counter Register） 字节码的行号指示器，程序控制流的指示器（分支、循环、跳转、异常处理、线程恢复"><meta property="og:type" content="article"><meta property="og:url" content="https://yzlc.github.io/post/read/jvm/2/"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-05-08T10:32:33+08:00"><meta property="article:modified_time" content="2023-11-08T18:05:59+08:00"><meta itemprop=name content="第2章　Java内存区域与内存溢出异常"><meta itemprop=description content="2.2 运行时数据区域 2.2.1 程序计数器（Program Counter Register） 字节码的行号指示器，程序控制流的指示器（分支、循环、跳转、异常处理、线程恢复"><meta itemprop=datePublished content="2020-05-08T10:32:33+08:00"><meta itemprop=dateModified content="2023-11-08T18:05:59+08:00"><meta itemprop=wordCount content="2610"><meta itemprop=keywords content="jvm,"><meta name=twitter:card content="summary"><meta name=twitter:title content="第2章　Java内存区域与内存溢出异常"><meta name=twitter:description content="2.2 运行时数据区域 2.2.1 程序计数器（Program Counter Register） 字节码的行号指示器，程序控制流的指示器（分支、循环、跳转、异常处理、线程恢复"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>yzlc</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/tags/><li class=mobile-menu-item>标签</li></a><a href=/post/web><li class=mobile-menu-item>网站大全</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>yzlc</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/tags/>标签</a></li><li class=menu-item><a class=menu-item-link href=/post/web>网站大全</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>第2章　Java内存区域与内存溢出异常</h1><div class=post-meta><span class=post-time>2020-05-08</span><div class=post-category><a href=/categories/read/>read</a></div><span class=more-meta>约 2610 字</span>
<span class=more-meta>预计阅读 6 分钟</span>
<span id=busuanzi_container_page_pv class=more-meta><span id=busuanzi_value_page_pv><img src=/img/spinner.svg alt=spinner.svg></span> 次阅读</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#22运行时数据区域>2.2　运行时数据区域</a><ul><li><a href=#221程序计数器program-counter-register>2.2.1　程序计数器（Program Counter Register）</a></li><li><a href=#222java虚拟机栈java-virtual-machine-stack>2.2.2　Java虚拟机栈（Java Virtual Machine Stack）</a></li><li><a href=#223本地方法栈native-method-stacks>2.2.3　本地方法栈（Native Method Stacks）</a></li><li><a href=#224java堆java-heap>2.2.4　Java堆（Java Heap）</a></li><li><a href=#225方法区method-area>2.2.5　方法区（Method Area）</a></li><li><a href=#226运行时常量池runtime-constant-pool>2.2.6　运行时常量池（Runtime Constant Pool）</a></li><li><a href=#227直接内存direct-memory>2.2.7　直接内存（Direct Memory）</a></li></ul></li><li><a href=#23hotspot虚拟机对象探秘>2.3　HotSpot虚拟机对象探秘</a><ul><li><a href=#231对象的创建>2.3.1　对象的创建</a></li><li><a href=#232对象的内存布局>2.3.2　对象的内存布局</a></li><li><a href=#233对象的访问定位>2.3.3　对象的访问定位</a></li></ul></li></ul></nav></div></div><div class=post-content><h2 id=22运行时数据区域>2.2　运行时数据区域</h2><p><img src=/images/read/jvm/2-1.jpg alt></p><h3 id=221程序计数器program-counter-register>2.2.1　程序计数器（Program Counter Register）</h3><blockquote><p>字节码的行号指示器，程序控制流的指示器（分支、循环、跳转、异常处理、线程恢复等）</p></blockquote><p>记录内容</p><ul><li>执行Java方法：记录虚拟机字节码指令地址</li><li>执行本地（Native）方法：值为空（Undefined）</li></ul><p>异常情况</p><ul><li>唯一一个没有规定OutOfMemoryError的区域</li></ul><h3 id=222java虚拟机栈java-virtual-machine-stack>2.2.2　Java虚拟机栈（Java Virtual Machine Stack）</h3><blockquote><p>Java方法执行的线程内存模型：方法被执行的时候，同步创建一个栈帧（Stack Frame）（存储局部变量表、操作数栈、动态连接、方法出口等信息）。方法执行过程对应栈帧从入栈到出栈的过程</p></blockquote><p>异常情况</p><ul><li>StackOverflow：线程请求的栈深度 > 虚拟机允许的深度</li><li>OutOfMemory：栈扩展无法申请到足够的内存时</li></ul><p>局部变量表</p><blockquote><p>存放基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型）和returnAddress类型（指向一条字节码指令的地址）</p></blockquote><ul><li>存储空间<ul><li>局部变量槽（Slot）：64位的long和double占用两个变量槽，其余的数据类型只占用一个</li></ul></li><li>内存分配<ul><li>在编译期完成分配：进入方法时，需要在栈帧中分配的局部变量空间是确定的，方法运行期间不会改变局部变量表的大小(变量槽的数量)</li></ul></li></ul><h3 id=223本地方法栈native-method-stacks>2.2.3　本地方法栈（Native Method Stacks）</h3><blockquote><p>为虚拟机使用到的本地（Native）方法服务</p></blockquote><h3 id=224java堆java-heap>2.2.4　Java堆（Java Heap）</h3><blockquote><p>在虚拟机启动时创建，几乎所有的对象实例都在这里分配内存。垃圾收集器管理的内存区域（GC堆（Garbage Collected Heap））</p></blockquote><p>异常情况</p><ul><li>OutOfMemory：没有内存完成实例分配，并且堆也无法再扩展</li></ul><h3 id=225方法区method-area>2.2.5　方法区（Method Area）</h3><blockquote><p>存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据</p></blockquote><p>异常情况</p><ul><li>OutOfMemory：方法区无法满足新的内存分配需求</li></ul><h3 id=226运行时常量池runtime-constant-pool>2.2.6　运行时常量池（Runtime Constant Pool）</h3><blockquote><p>方法区的一部分。Class文件中的常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，类加载后存放到运行时常量池中</p></blockquote><p>对比Class文件常量池</p><ul><li>Class文件的格式有严格规定，运行时常量池没有做任何细节的要求（一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中）</li><li>运行时常量池具备动态性，运行期间可以将新的常量放入池中，例如String类的intern()方法</li></ul><p>异常情况</p><ul><li>OutOfMemory：常量池无法再申请到内存</li></ul><h3 id=227直接内存direct-memory>2.2.7　直接内存（Direct Memory）</h3><blockquote><p>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。使用Native函数库直接分配堆外内存，通过存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作</p></blockquote><p>特点</p><ul><li>能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据</li></ul><p>异常情况</p><ul><li>OutOfMemory：忽略直接内存，使得各个内存区域总和大于物理内存限制，导致动态扩展</li></ul><h2 id=23hotspot虚拟机对象探秘>2.3　HotSpot虚拟机对象探秘</h2><h3 id=231对象的创建>2.3.1　对象的创建</h3><blockquote><p>new -> 检查常量池中类是否已被加载 -> 分配内存 -> 初始化零值 -> 设置对象头 -> 执行构造函数</p></blockquote><p>内存分配方式(由堆是否规整决定)</p><ul><li>指针碰撞（Bump The Pointer）：内存规整，使用的放一边，空闲的放一边，中间放指针作为分界点的指示器，分配内存就是把那个指针向空闲空间方向挪动与对象大小相等的距离</li><li>空闲列表（Free List）：内存不规整，维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录</li></ul><p>堆是否规整</p><ul><li>使用Serial、ParNew等带压缩整理（Compact）</li><li>使用CMS基于清除（Sweep）算法的收集器</li></ul><p>线程安全</p><ul><li>同步处理：CAS配上失败重试的方式保证更新操作的原子性</li><li>按线程划分在不同的空间之中进行：TLAB，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定<ul><li>本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）：每个线程在Java堆中预先分配一小块内存</li></ul></li></ul><p>对象头（Object Header）：对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（真正调hashCode()时计算）、对象的GC分代年龄等</p><h3 id=232对象的内存布局>2.3.2　对象的内存布局</h3><blockquote><p>对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）</p></blockquote><p>对象头</p><ul><li><p>Mark Word：存储对象自身的运行时数据，有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间，长度为32个比特(32位)和64个比特(64位)</p><table><thead><tr><th>存储内容</th><th>标志</th><th>状态</th></tr></thead><tbody><tr><td>对象哈希码、对象分代年龄</td><td>01</td><td>未锁定</td></tr><tr><td>指向锁记录的指针</td><td>00</td><td>轻量级锁定</td></tr><tr><td>指向重量级锁的指针</td><td>10</td><td>膨胀(重量级锁定)</td></tr><tr><td>空,不需要记录信息</td><td>11</td><td>GC标记</td></tr><tr><td>偏向线程ID、偏向时间戳、对象分代年龄</td><td>01</td><td>可偏向</td></tr></tbody></table></li><li><p>类型指针：对象指向它的类型元数据的指针，通过指针来确定对象是哪个类的实例</p><ul><li>不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身</li><li>数组在对象头中必须有一块用于记录数组长度的数据：元数据信息可以确定Java对象的大小，但如果数组的长度是不确定的，无法通过元数据中的信息推断出数组的大小</li></ul></li></ul><p>实例数据：对象真正存储的有效信息，代码中各种类型的字段内容，无论父类继承还是子类定义的字段都记录起来</p><p>对齐填充：占位符的作用。HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍</p><h3 id=233对象的访问定位>2.3.3　对象的访问定位</h3><blockquote><p>通过栈上的reference数据来操作堆上的具体对象，主流的访问方式有句柄和直接指针两种</p></blockquote><p>句柄：划分出一块内存来作为句柄池，reference中存储的对象的句柄地址，句柄中包含对象实例数据与类型数据各自具体的地址信息
<img src=/images/read/jvm/2-2.jpg alt title=通过句柄访问对象></p><ul><li>好处： reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改</li></ul><p>直接指针：必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，只访问对象本身的话，就不需要多一次间接访问的开销
<img src=/images/read/jvm/2-3.jpg alt title=通过直接指针访问对象></p><ul><li>好处： 速度更快，节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本</li></ul></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>YZLC</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2023-11-08
<a href=https://github.com/yzlc/www/commit/b7d04a9e41defee68b6966e68586424402ed08ff title=1>(b7d04a9)</a></span></p><p class=copyright-item><span class=item-title>许可协议</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-ND 4.0</a></span></p></div><div class=post-reward><input type=checkbox name=reward id=reward hidden>
<label class=reward-button for=reward>赞赏支持</label><div class=qr-code><label class=qr-code-image for=reward><img class=image src=/images/reward/wechat.jpg>
<span>微信打赏</span></label>
<label class=qr-code-image for=reward><img class=image src=/images/reward/alipay.jpg>
<span>支付宝打赏</span></label></div></div><footer class=post-footer><div class=post-tags><a href=/tags/jvm/>jvm</a></div><nav class=post-nav><a class=prev href=/post/read/jvm/3/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">第3章　内存分配策略</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=/post/read/jvm/1/><span class="next-text nav-default">第1章　走近Java</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><div id=vcomments></div><script src=//cdn1.lncld.net/static/js/3.0.4/av-min.js></script>
<script src=//unpkg.com/valine/dist/Valine.min.js></script>
<script type=text/javascript>new Valine({el:"#vcomments",appId:"eqLcOvlY4d8bxdMA47BQqwRV-gzGzoHsz",appKey:"fhXztPgcCKoM3Tlof1DEGnB8",notify:!1,verify:!1,avatar:"mm",placeholder:"说点什么吧...",visitor:!1})</script></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:yzlc233@outlook.com class="iconfont icon-email" title=email></a>
<a href=https://github.com/yzlc class="iconfont icon-github" title=github></a>
<a href=https://space.bilibili.com/10341737 class="iconfont icon-bilibili" title=bilibili></a>
<a href=https://yzlc.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span><div class=busuanzi-footer><span id=busuanzi_container_site_pv>本站总访问量 <span id=busuanzi_value_site_pv><img src=/img/spinner.svg alt=spinner.svg></span> 次</span>
<span class=division>|</span>
<span id=busuanzi_container_site_uv>本站总访客数 <span id=busuanzi_value_site_uv><img src=/img/spinner.svg alt=spinner.svg></span> 人</span></div><span class=copyright-year>&copy;
2019 -
2023<span class=heart><i class="iconfont icon-heart"></i></span><span>YZLC</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script>
<script type=text/javascript>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-154585647-1","auto"),ga("set","anonymizeIp",!0),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>