<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>分布式 on YZLC</title><link>https://yzlc.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/</link><description>Recent content in 分布式 on YZLC</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 12 May 2021 09:52:33 +0800</lastBuildDate><atom:link href="https://yzlc.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>分布式</title><link>https://yzlc.github.io/post/note/dev/java/distributed/</link><pubDate>Wed, 12 May 2021 09:52:33 +0800</pubDate><guid>https://yzlc.github.io/post/note/dev/java/distributed/</guid><description>&lt;blockquote>
&lt;p>拆分成多个子服务,将这些子服务都部署在不同的服务器上&lt;/p>
&lt;/blockquote>
&lt;h2 id="caphttpszhwikipediaorgwikicape5ae9ae79086">&lt;a class="link" href="https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86" target="_blank" rel="noopener"
>CAP&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>因为P的存在，要求我们在A和C中做出权衡&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>一致性（Consistency）：所有节点访问同一份最新数据&lt;/li>
&lt;li>可用性（Availability）：每次请求都能获取到非错的响应&lt;/li>
&lt;li>分区容错性（Partition tolerance）：对通信的时限要求&lt;/li>
&lt;/ul>
&lt;h2 id="paxos算法">Paxos算法&lt;/h2>
&lt;blockquote>
&lt;p>消息传递且具有高度容错特性的一致性算法，其解决的问题就是在分布式系统中如何就某个值（决议）达成一致。Proposer提案者、Acceptor表决者、Learner学习者。两个阶段，分别为 Prepare和accept阶段&lt;/p>
&lt;/blockquote>
&lt;h3 id="prepare阶段">prepare阶段&lt;/h3>
&lt;ul>
&lt;li>Proposer提案者：负责提出 proposal，每个提案者在提出提案时都会首先获取到一个 具有全局唯一性的、递增的提案编号N，即在整个集群中是唯一的编号 N，然后将该编号赋予其要提出的提案，在第一阶段是只将提案编号发送给所有的表决者&lt;/li>
&lt;li>Acceptor表决者：每个表决者在 accept 某提案后，会将该提案编号N记录在本地，这样每个表决者中保存的已经被 accept 的提案中会存在一个编号最大的提案，其编号假设为maxN。每个表决者仅会 accept 编号大于自己本地 maxN 的提案，在批准提案时表决者会将以前接受过的最大编号的提案作为响应反馈给Proposer&lt;/li>
&lt;/ul>
&lt;h3 id="accept阶段">accept阶段&lt;/h3>
&lt;p>当一个提案被 Proposer 提出后，如果 Proposer 收到了超过半数的 Acceptor 的批准（Proposer 本身同意），那么此时 Proposer 会给所有的 Acceptor 发送真正的提案（你可以理解为第一阶段为试探），这个时候 Proposer 就会发送提案的内容和提案编号。&lt;/p>
&lt;p>表决者收到提案请求后会再次比较本身已经批准过的最大提案编号和该提案编号，如果该提案编号 大于等于 已经批准过的最大提案编号，那么就 accept 该提案（此时执行提案内容但不提交），随后将情况返回给 Proposer 。如果不满足则不回应或者返回 NO 。&lt;/p>
&lt;p>paxos第二阶段1&lt;/p>
&lt;p>当 Proposer 收到超过半数的 accept ，那么它这个时候会向所有的 acceptor 发送提案的提交请求。需要注意的是，因为上述仅仅是超过半数的 acceptor 批准执行了该提案内容，其他没有批准的并没有执行该提案内容，所以这个时候需要向未批准的 acceptor 发送提案内容和提案编号并让它无条件执行和提交，而对于前面已经批准过该提案的 acceptor 来说 仅仅需要发送该提案的编号 ，让 acceptor 执行提交就行了。&lt;/p>
&lt;p>paxos第二阶段2&lt;/p>
&lt;p>而如果 Proposer 如果没有收到超过半数的 accept 那么它将会将 递增 该 Proposal 的编号，然后 重新进入 Prepare 阶段&lt;/p></description></item><item><title>ZooKeeper</title><link>https://yzlc.github.io/post/note/dev/java/zookeeper/</link><pubDate>Wed, 12 May 2021 09:23:33 +0800</pubDate><guid>https://yzlc.github.io/post/note/dev/java/zookeeper/</guid><description>&lt;blockquote>
&lt;p>分布式协调服务（动物园管理员）。提供了高可用、高性能、稳定的分布式数据一致性解决方案，通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能&lt;/p>
&lt;/blockquote>
&lt;h2 id="data-model数据模型">Data model（数据模型）&lt;/h2>
&lt;blockquote>
&lt;p>多叉树形结构，根节点以“/”来代表。数据节点被称为znode（&amp;quot;/&amp;ldquo;路径表示）&lt;/p>
&lt;/blockquote>
&lt;h3 id="znode类型">znode类型&lt;/h3>
&lt;blockquote>
&lt;p>znode由2部分组成：stat（状态信息）、data（数据）&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>持久（PERSISTENT）节点：一旦创建就一直存在即使ZooKeeper集群宕机，直到将其删除。&lt;/li>
&lt;li>临时（EPHEMERAL）节点：临时节点的生命周期是与 客户端会话（session） 绑定的，会话消失则节点消失 。并且，临时节点只能做叶子节点 ，不能创建子节点。&lt;/li>
&lt;li>持久顺序（PERSISTENT_SEQUENTIAL）节点：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 /node1/app0000000001 、/node1/app0000000002 。&lt;/li>
&lt;li>临时顺序（EPHEMERAL_SEQUENTIAL）节点：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。&lt;/li>
&lt;/ul>
&lt;h2 id="acl权限控制">ACL（权限控制）&lt;/h2>
&lt;h3 id="znode">znode&lt;/h3>
&lt;ul>
&lt;li>CREATE : 能创建子节点&lt;/li>
&lt;li>READ ：能获取节点数据和列出其子节点&lt;/li>
&lt;li>WRITE : 能设置/更新节点数据&lt;/li>
&lt;li>DELETE : 能删除子节点&lt;/li>
&lt;li>ADMIN : 能设置节点 ACL 的权限&lt;/li>
&lt;/ul>
&lt;h3 id="身份认证">身份认证&lt;/h3>
&lt;ul>
&lt;li>world ： 默认方式，所有用户都可无条件访问。&lt;/li>
&lt;li>auth :不使用任何 id，代表任何已认证的用户。&lt;/li>
&lt;li>digest :用户名:密码认证方式： username:password 。&lt;/li>
&lt;li>ip : 对指定 ip 进行限制。&lt;/li>
&lt;/ul>
&lt;h2 id="watcher事件监听器">Watcher（事件监听器）&lt;/h2>
&lt;blockquote>
&lt;p>允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性&lt;/p>
&lt;/blockquote></description></item></channel></rss>