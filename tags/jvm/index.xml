<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>jvm on YZLC</title><link>https://yzlc.github.io/tags/jvm/</link><description>Recent content in jvm on YZLC</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 03 Jun 2020 10:32:33 +0800</lastBuildDate><atom:link href="https://yzlc.github.io/tags/jvm/index.xml" rel="self" type="application/rss+xml"/><item><title>第12章　Java内存模型与线程</title><link>https://yzlc.github.io/post/read/jvm/12/</link><pubDate>Wed, 03 Jun 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/jvm/12/</guid><description>&lt;h2 id="121概述">12.1　概述&lt;/h2>
&lt;p>每秒事务处理数（Transactions Per Second，TPS）&lt;/p>
&lt;h2 id="123java内存模型">12.3　Java内存模型&lt;/h2>
&lt;blockquote>
&lt;p>定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节&lt;/p>
&lt;/blockquote>
&lt;p>变量（Variables）包括实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数(线程私有)&lt;/p>
&lt;h3 id="1231主内存与工作内存">12.3.1　主内存与工作内存&lt;/h3>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/jvm/12-2.jpg"
loading="lazy"
>&lt;/p>
&lt;h3 id="1232内存间交互操作">12.3.2　内存间交互操作&lt;/h3>
&lt;p>操作&lt;/p>
&lt;ul>
&lt;li>lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态&lt;/li>
&lt;li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定&lt;/li>
&lt;li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用&lt;/li>
&lt;li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中&lt;/li>
&lt;li>use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作&lt;/li>
&lt;li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作&lt;/li>
&lt;li>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用&lt;/li>
&lt;li>write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中&lt;/li>
&lt;/ul>
&lt;p>规定&lt;/p>
&lt;ul>
&lt;li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现&lt;/li>
&lt;li>不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存&lt;/li>
&lt;li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中&lt;/li>
&lt;li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use、store操作之前，必须先执行assign和load操作&lt;/li>
&lt;li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁&lt;/li>
&lt;li>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作以初始化变量的值&lt;/li>
&lt;li>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量&lt;/li>
&lt;li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）&lt;/li>
&lt;/ul>
&lt;h3 id="1233对于volatile型变量的特殊规则">12.3.3　对于volatile型变量的特殊规则&lt;/h3>
&lt;blockquote>
&lt;p>可见性、禁止指令重排序优化。选择依据仅仅是volatile的语义能否满足使用场景的需求&lt;/p>
&lt;/blockquote>
&lt;p>可见性规则&lt;/p>
&lt;ul>
&lt;li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值&lt;/li>
&lt;li>变量不需要与其他的状态变量共同参与不变约束&lt;/li>
&lt;/ul>
&lt;h3 id="1234针对long和double型变量的特殊规则">12.3.4　针对long和double型变量的特殊规则&lt;/h3>
&lt;blockquote>
&lt;p>非原子性协定（Non-Atomic Treatment of double and long Variables）：虚拟机自行选择是否要保证64位数据类型的load、store、read和write操作的原子性。除非该数据有明确可知的线程竞争，否则不需要把long和double声明为volatile&lt;/p>
&lt;/blockquote>
&lt;h3 id="1235原子性可见性与有序性">12.3.5　原子性、可见性与有序性&lt;/h3>
&lt;ol>
&lt;li>原子性（Atomicity）：基本数据类型的访问、读写都是具备原子性的，synchronized块&lt;/li>
&lt;li>可见性（Visibility）：volatile、synchronized和final（被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去）&lt;/li>
&lt;li>有序性（Ordering）：volatile和synchronized&lt;/li>
&lt;/ol>
&lt;h3 id="1236先行发生原则happens-before">12.3.6　先行发生原则（Happens-Before）&lt;/h3>
&lt;p>程序次序规则（Program Order Rule）：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构&lt;/p>
&lt;p>管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是“同一个锁”，而“后面”是指时间上的先后&lt;/p>
&lt;p>volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后&lt;/p>
&lt;p>线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作&lt;/p>
&lt;p>线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行&lt;/p>
&lt;p>线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread::interrupted()方法检测到是否有中断发生&lt;/p>
&lt;p>对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始&lt;/p>
&lt;p>传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论&lt;/p>
&lt;h3 id="124java与线程">12.4　Java与线程&lt;/h3>
&lt;h4 id="1241线程的实现">12.4.1　线程的实现&lt;/h4>
&lt;ol>
&lt;li>内核线程实现（Kernel-Level Thread，KLT）：1(轻量级进程)：1(内核线程)
&lt;ul>
&lt;li>内核线程：是直接由操作系统内核（Kernel，下称内核）支持的线程，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。&lt;/li>
&lt;li>轻量级进程（Light Weight Process，LWP）：程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口——轻量级进程，轻量级进程就是我们通常意义上所讲的线程
&lt;ul>
&lt;li>系统调用的代价相对较高：基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用,需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换。&lt;/li>
&lt;li>系统支持轻量级进程的数量是有限的：轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间）
&lt;img src="https://yzlc.github.io/images/read/jvm/12-3.jpg"
loading="lazy"
>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>用户线程实现（User Thread，UT）：1（进程）：N（用户线程）
&lt;img src="https://yzlc.github.io/images/read/jvm/12-4.jpg"
loading="lazy"
>&lt;/li>
&lt;li>混合实现：N（内核线程）：M（用户线程）
&lt;img src="https://yzlc.github.io/images/read/jvm/12-5.jpg"
loading="lazy"
>&lt;/li>
&lt;li>Java线程的实现
1:1模型，线程模型只对线程的并发规模和操作成本产生影响，对Java程序的编码和运行过程来说，这些差异都是完全透明的&lt;/li>
&lt;/ol>
&lt;h4 id="1242java线程调度">12.4.2　Java线程调度&lt;/h4>
&lt;blockquote>
&lt;p>系统为线程分配处理器使用权的过程&lt;/p>
&lt;/blockquote>
&lt;p>调度方式&lt;/p>
&lt;ul>
&lt;li>协同式（Cooperative Threads-Scheduling）线程调度：执行时间由线程本身来控制，工作执行完之后，主动通知系统切换到另外一个线程上去
&lt;ul>
&lt;li>实现简单&lt;/li>
&lt;li>切换操作对线程自己是可知的，一般没有线程同步问题&lt;/li>
&lt;li>线程执行时间不可控制&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>抢占式（Preemptive Threads-Scheduling）线程调度：由系统来分配执行时间
&lt;ul>
&lt;li>线程的执行时间是系统可控&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="1243状态转换">12.4.3　状态转换&lt;/h4>
&lt;p>新建（New）：创建后尚未启动的线程处于这种状态&lt;br>
运行（Runnable）：包括操作系统线程状态中的Running和Ready，可能正在执行，也有可能正在等待着操作系统为它分配执行时间&lt;br>
无限期等待（Waiting）：不会被分配处理器执行时间，等待被其他线程显式唤醒&lt;/p>
&lt;ul>
&lt;li>没有设置Timeout参数的Object::wait()方法&lt;/li>
&lt;li>没有设置Timeout参数的Thread::join()方法&lt;/li>
&lt;li>LockSupport::park()方法&lt;/li>
&lt;/ul>
&lt;p>限期等待（Timed Waiting）：不会被分配处理器执行时间，在一定时间之后由系统自动唤醒&lt;/p>
&lt;ul>
&lt;li>Thread::sleep()方法&lt;/li>
&lt;li>设置了Timeout参数的Object::wait()方法&lt;/li>
&lt;li>设置了Timeout参数的Thread::join()方法&lt;/li>
&lt;li>LockSupport::parkNanos()方法&lt;/li>
&lt;li>LockSupport::parkUntil()方法&lt;/li>
&lt;/ul>
&lt;p>阻塞（Blocked）：线程被阻塞了，等待着获取到一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生&lt;br>
结束（Terminated）：已终止线程的线程状态，线程已经结束执行
&lt;img src="https://yzlc.github.io/images/read/jvm/12-6.jpg"
loading="lazy"
>&lt;/p>
&lt;h3 id="125java与协程">12.5　Java与协程&lt;/h3>
&lt;h4 id="1251内核线程的局限">12.5.1　内核线程的局限&lt;/h4>
&lt;h4 id="1252协程的复苏">12.5.2　协程的复苏&lt;/h4>
&lt;p>协程（Coroutine）：用户线程设计成协同式调度（Cooperative Scheduling）&lt;/p>
&lt;ul>
&lt;li>有栈协程（Stackfull Coroutine）：完整地做调用栈的保护、恢复工作&lt;/li>
&lt;li>无栈协程（Stackless Coroutine）：各种语言中的await、async、yield这类关键字。本质上是一种有限状态机，状态保存在闭包里，比有栈协程恢复调用栈要轻量得多，但功能也相对更有限&lt;/li>
&lt;/ul>
&lt;p>特点：比传统内核线程要轻量，需要在应用层面实现的内容（调用栈、调度器）特别多&lt;/p>
&lt;h4 id="1253java的解决方案">12.5.3　Java的解决方案&lt;/h4></description></item><item><title>第13章　线程安全与锁优化</title><link>https://yzlc.github.io/post/read/jvm/13/</link><pubDate>Wed, 03 Jun 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/jvm/13/</guid><description>&lt;h2 id="132线程安全">13.2　线程安全&lt;/h2>
&lt;h3 id="1321java语言中的线程安全">13.2.1　Java语言中的线程安全&lt;/h3>
&lt;ol>
&lt;li>不可变
&lt;ul>
&lt;li>基本数据类型：在定义时使用final关键字修饰&lt;/li>
&lt;li>对象：需要保证其行为不会对其状态产生任何影响(String)，最简单的方法就是把对象里面带有状态的变量都声明为final&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>绝对线程安全&lt;br>
付出的时间和空间成本都非常大&lt;/li>
&lt;li>相对线程安全&lt;br>
大部分声称线程安全的类都属于这种类型&lt;/li>
&lt;li>线程兼容&lt;br>
对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用&lt;/li>
&lt;li>线程对立&lt;br>
线程对立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码&lt;/li>
&lt;/ol>
&lt;h3 id="1322线程安全的实现方法">13.2.2　线程安全的实现方法&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>互斥同步（Mutual Exclusion &amp;amp; Synchronization）：最常见也是最主要的并发正确性保障手段,悲观的并发策略,也被称为阻塞同步（Blocking Synchronization）&lt;/p>
&lt;p>概念&lt;/p>
&lt;ul>
&lt;li>同步：在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条（或者是一些，当使用信号量的时候）线程使用&lt;/li>
&lt;li>互斥：实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是常见的互斥实现方式&lt;/li>
&lt;/ul>
&lt;p>使用&lt;/p>
&lt;ul>
&lt;li>
&lt;p>synchronized（推荐）&lt;/p>
&lt;ul>
&lt;li>被synchronized修饰的同步块对同一条线程来说是可重入的&lt;/li>
&lt;li>被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>重入锁（ReentrantLock）&lt;/p>
&lt;ul>
&lt;li>等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情&lt;/li>
&lt;li>公平锁：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁&lt;/li>
&lt;li>锁绑定多个条件：一个ReentrantLock对象可以同时绑定多个Condition对象&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>区别&lt;/p>
&lt;ul>
&lt;li>synchronized是在Java语法层面的同步，清晰，简单&lt;/li>
&lt;li>Lock应该确保在finally块中释放锁，否则一旦受同步保护的代码块中抛出异常，则有可能永远不会释放持有的锁&lt;/li>
&lt;li>Java虚拟机更容易针对synchronized来进行优化&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>非阻塞同步：共享数据冲突，再进行补偿措施，最常用的补偿措施是不断地重试，直到出现没有竞争的共享数据为止。这种乐观并发策略的实现不再需要把线程阻塞挂起，使用这种措施的代码也常被称为无锁（Lock-Free）编程&lt;/p>
&lt;p>处理器指令&lt;/p>
&lt;ul>
&lt;li>测试并设置（Test-and-Set）&lt;/li>
&lt;li>获取并增加（Fetch-and-Increment）&lt;/li>
&lt;li>交换（Swap）&lt;/li>
&lt;li>比较并交换（Compare-and-Swap，下文称CAS）&lt;/li>
&lt;li>加载链接/条件储存（Load-Linked/Store-Conditional，下文称LL/SC）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>无同步方案&lt;/p>
&lt;p>可重入代码（Reentrant Code）：这种代码又称纯代码（Pure Code），是指可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误，也不会对结果有所影响
如果一个方法的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的&lt;/p>
&lt;p>线程本地存储（Thread Local Storage）：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题.ThreadLocal&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="133锁优化">13.3　锁优化&lt;/h2>
&lt;h3 id="1331自旋锁与自适应自旋">13.3.1　自旋锁与自适应自旋&lt;/h3>
&lt;blockquote>
&lt;p>自旋锁：为了让线程等待，我们只须让线程执行一个忙循环（自旋）
自适应：由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的&lt;/p>
&lt;/blockquote>
&lt;h3 id="1332锁消除">13.3.2　锁消除&lt;/h3>
&lt;blockquote>
&lt;p>即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除(逃逸分析)&lt;/p>
&lt;/blockquote>
&lt;h3 id="1333锁粗化">13.3.3　锁粗化&lt;/h3>
&lt;blockquote>
&lt;p>将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步&lt;/p>
&lt;/blockquote>
&lt;h3 id="1334轻量级锁">13.3.4　轻量级锁&lt;/h3>
&lt;p>不同状态下对象头的存储内容
&lt;img src="https://yzlc.github.io/images/read/jvm/13-1.jpg"
loading="lazy"
>&lt;/p>
&lt;p>工作过程&lt;/p>
&lt;ol>
&lt;li>在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（这份拷贝加了Displaced前缀，即Displaced Mark Word）&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/jvm/13-3.jpg"
loading="lazy"
>&lt;/p>
&lt;ol start="2">
&lt;li>使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针。Mark Word的锁标志位将转变为“00”&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/jvm/13-4.jpg"
loading="lazy"
>&lt;/p>
&lt;h3 id="1335偏向锁">13.3.5　偏向锁&lt;/h3>
&lt;blockquote>
&lt;p>偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需
要再进行同步&lt;/p>
&lt;/blockquote>
&lt;p>状态转换关系
&lt;img src="https://yzlc.github.io/images/read/jvm/13-5.jpg"
loading="lazy"
>&lt;/p></description></item><item><title>第11章　后端编译与优化</title><link>https://yzlc.github.io/post/read/jvm/11/</link><pubDate>Tue, 02 Jun 2020 11:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/jvm/11/</guid><description>&lt;h2 id="112即时编译器">11.2　即时编译器&lt;/h2>
&lt;blockquote>
&lt;p>Java程序最初都是通过解释器（Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为“热点代码”（Hot Spot Code），虚拟机将会把这些代码编译成本地机器码，并以各种手段尽可能地进行代码优化，运行时完成这个任务的后端编译器被称为即时编译器&lt;/p>
&lt;/blockquote>
&lt;h3 id="1121解释器与编译器">11.2.1　解释器与编译器&lt;/h3>
&lt;p>解释器&lt;/p>
&lt;ul>
&lt;li>省去编译的时间，立即运行&lt;/li>
&lt;li>节约内存&lt;/li>
&lt;li>作为编译器激进优化时后备的逃生门&lt;/li>
&lt;/ul>
&lt;p>编译器&lt;/p>
&lt;ul>
&lt;li>编译成本地代码，减少解释器的中间损耗，获得更高的执行效率&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/jvm/11-1.jpg"
loading="lazy"
>&lt;/p>
&lt;p>分层编译&lt;/p>
&lt;ul>
&lt;li>第0层。程序纯解释执行，不开启性能监控功能（Profiling）&lt;/li>
&lt;li>第1层。使用客户端编译器将字节码编译为本地代码来运行，进行简单可靠的稳定优化，不开启性能监控功能&lt;/li>
&lt;li>第2层。仍然使用客户端编译器执行，仅开启方法及回边次数统计等有限的性能监控功能&lt;/li>
&lt;li>第3层。仍然使用客户端编译器执行，开启全部性能监控，除了第2层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部的统计信息&lt;/li>
&lt;li>第4层。使用服务端编译器将字节码编译为本地代码，相比起客户端编译器，服务端编译器会启用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/jvm/11-2.jpg"
loading="lazy"
>&lt;/p>
&lt;h3 id="1122编译对象与触发条件">11.2.2　编译对象与触发条件&lt;/h3>
&lt;p>热点代码（编译对象都是方法）&lt;/p>
&lt;ul>
&lt;li>被多次调用的方法&lt;/li>
&lt;li>被多次执行的循环体
&lt;ul>
&lt;li>栈上替换（On Stack Replacement，OSR）： 编译时传入执行入口点字节码序号（Byte Code Index，BCI）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>热点探测&lt;/p>
&lt;ul>
&lt;li>基于采样的热点探测（Sample Based Hot Spot Code Detection）。周期性地检查各个线程的调用栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”
&lt;ul>
&lt;li>实现简单高效，还可以很容易地获取方法调用关系&lt;/li>
&lt;li>很难精确地确认一个方法的热度，容易受到线程阻塞或别的外界因素的影响&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>基于计数器的热点探测（Counter Based Hot Spot Code Detection）。为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是“热点方法”
&lt;ul>
&lt;li>实现起来要麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系&lt;/li>
&lt;li>统计结果相对来说更加精确严谨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>计数器&lt;/p>
&lt;ul>
&lt;li>方法调用计数器（Invocation Counter）： 统计方法被调用的次数
&lt;ul>
&lt;li>热度的衰减（Counter Decay）： 当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那该方法的调用计数器就会被减少一半，这段时间就称为此方法统计的半衰周期（Counter Half Life Time）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>回边计数器（Back Edge Counter，“回边”的意思就是指在循环边界往回跳转）&lt;/li>
&lt;/ul>
&lt;h3 id="1123编译过程">11.2.3　编译过程&lt;/h3>
&lt;p>高级中间代码表示（High-Level Intermediate Representation，HIR，即与目标机器指令集无关的中间表示）。&lt;/p>
&lt;p>静态单分配（Static Single Assignment，SSA）&lt;/p>
&lt;p>低级中间代码表示（Low-Level IntermediateRepresentation，LIR，即与目标机器指令集相关的中间表示）&lt;/p>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/jvm/11-5.jpg"
loading="lazy"
>&lt;/p>
&lt;h3 id="113提前编译器">11.3　提前编译器&lt;/h3>
&lt;h4 id="1131提前编译的优劣得失">11.3.1　提前编译的优劣得失&lt;/h4>
&lt;h3 id="114编译器优化技术">11.4　编译器优化技术&lt;/h3>
&lt;h4 id="1142方法内联">11.4.2　方法内联&lt;/h4>
&lt;blockquote>
&lt;p>把目标方法的代码原封不动地“复制”到发起调用的方法之中，避免发生真实的方法调用&lt;/p>
&lt;/blockquote>
&lt;p>虚方法内联问题&lt;/p>
&lt;ul>
&lt;li>类型继承关系分析（Class HierarchyAnalysis，CHA）: 这是整个应用程序范围内的类型分析技术，用于确定在目前已加载的类中，某个接口是否有多于一种的实现、某个类是否存在子类、某个子类是否覆盖了父类的某个虚方法等信息
&lt;ul>
&lt;li>守护内联（Guarded Inlining）: 查询到只有一个版本&lt;/li>
&lt;li>内联缓存（Inline Cache）: 查询到多个版本，建立在目标方法正常入口之前的缓存,记录下方法接收者的版本信息
&lt;ul>
&lt;li>单态内联缓存（Monomorphic Inline Cache）： 每次调用的方法接收者版本都是一样的&lt;/li>
&lt;li>超多态内联缓存（Megamorphic Inline Cache）： 方法接收者不一致&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="1143逃逸分析escape-analysis">11.4.3　逃逸分析（Escape Analysis）&lt;/h4>
&lt;p>基本原理&lt;/p>
&lt;ul>
&lt;li>方法逃逸： 当一个对象在方法里面被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中&lt;/li>
&lt;li>线程逃逸： 被外部线程访问，譬如赋值给可以在其他线程中访问的实例变量&lt;/li>
&lt;/ul>
&lt;p>优化&lt;/p>
&lt;ul>
&lt;li>栈上分配（Stack Allocations）：如果确定一个对象不会逃逸出线程之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存
空间就可以随栈帧出栈而销毁。支持方法逃逸，不支持线程逃逸&lt;/li>
&lt;li>标量替换（Scalar Replacement）：把一个Java对象拆散，根据程序访问的情况，将其用到的成员变量恢复为原始类型来访问。它不允许对象逃逸出方法范围内。
&lt;ul>
&lt;li>标量: 一个数据已经无法再分解成更小的数据来表示了（int、long等数值类型及reference类型等）&lt;/li>
&lt;li>聚合量（Aggregate）: 一个数据可以继续分解(对象)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>同步消除（Synchronization Elimination）：如果确定一个变量不会逃逸出线程，无法被其他线程访问，对这个变量实施的同步措施也就可以安全地消除掉。&lt;/li>
&lt;/ul>
&lt;h4 id="1144公共子表达式消除">11.4.4　公共子表达式消除&lt;/h4>
&lt;blockquote>
&lt;p>如果一个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化&lt;/p>
&lt;/blockquote>
&lt;p>局部公共子表达式消除（Local Common Subexpression Elimination）: 优化仅限于程序基本块内&lt;br>
全局公共子表达式消除（Global Common Subexpression Elimination）: 优化的范围涵盖了多个基本块&lt;/p>
&lt;h4 id="1145数组边界检查消除array-bounds-checking-elimination">11.4.5　数组边界检查消除（Array Bounds Checking Elimination）&lt;/h4></description></item><item><title>第10章　前端编译与优化</title><link>https://yzlc.github.io/post/read/jvm/10/</link><pubDate>Tue, 02 Jun 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/jvm/10/</guid><description>&lt;h2 id="102javac编译器">10.2　Javac编译器&lt;/h2>
&lt;h3 id="1021javac的源码与调试">10.2.1　Javac的源码与调试&lt;/h3>
&lt;p>&lt;a class="link" href="http://hg.openjdk.java.net/jdk8/jdk8/langtools/file/1ff9d5118aae/src/share/classes/com/sun" target="_blank" rel="noopener"
>下载&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/jvm/10-4.jpg"
loading="lazy"
>&lt;/p>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/jvm/10-5.jpg"
loading="lazy"
>&lt;/p>
&lt;h3 id="1022解析与填充符号表">10.2.2　解析与填充符号表&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>词法、语法分析&lt;/p>
&lt;ul>
&lt;li>词法分析: 将源代码的字符流转变为标记（Token）集合的过程，单个字符是程序编写时的最小元素，但标记才是编译时的最小元素。关键字、变量名、字面量、运算符都可以作为标记，如“inta=b+2”标记是int、a、=、b、+、2。由com.sun.tools.javac.parser.Scanner类来实现。&lt;/li>
&lt;li>语法分析: 根据标记序列构造抽象语法树的过程，抽象语法树（Abstract Syntax Tree，AST）是一种用来描述程序代码语法结构的树形表示方式，抽象语法树的每一个节点都代表着程序代码中的一个语法结构（Syntax Construct），例如包、类型、修饰符、运算符、接口、返回值甚至连代码注释等都可以是一种特定的语法结构。由com.sun.tools.javac.parser.Parser类实现&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>填充符号表&lt;br>
符号表（Symbol Table）是由一组符号地址和符号信息构成的数据结构。符号表中所登记的信息在编译的不同阶段都要被用到。譬如在语义分析的过程中，符号表所登记的内容将用于语义检查和产生中间代码，在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的直接依据。由com.sun.tools.javac.comp.Enter类实现，该过程的产出物是一个待处理列表，其中包含了每一个编译单元的抽象语法树的顶级节点，以及package-info.java的顶级节点&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="1023注解处理器">10.2.3　注解处理器&lt;/h3>
&lt;h3 id="1024语义分析与字节码生成">10.2.4　语义分析与字节码生成&lt;/h3>
&lt;blockquote>
&lt;p>语义分析的任务是对源程序进行上下文检查，譬如类型检查、控制流检查、数据流检查等&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>标注检查&lt;br>
检查变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等,还会顺便进行一个称为常量折叠（Constant Folding）的代码优化(例如int a = 1 + 2;优化为3).实现类是com.sun.tools.javac.comp.Attr类和com.sun.tools.javac.comp.Check类&lt;/li>
&lt;li>数据及控制流分析&lt;br>
对程序上下文逻辑更进一步的验证，检查程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等.编译时期与类加载时校验范围有所区别，有一些校验项只有在编译期或运行期才能进行(例如final语义校验).由com.sun.tools.javac.comp.Flow类来完成&lt;/li>
&lt;li>解语法糖&lt;br>
由desugar()方法触发，在com.sun.tools.javac.comp.TransTypes类和com.sun.tools.javac.comp.Lower类中完成&lt;/li>
&lt;li>字节码生成&lt;br>
由com.sun.tools.javac.jvm.Gen类来完成。不仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码指令
写到磁盘中，还进行了少量的代码添加和转换工作&lt;/li>
&lt;/ol>
&lt;h2 id="103java语法糖的味道">10.3　Java语法糖的味道&lt;/h2>
&lt;h3 id="1031泛型">10.3.1　泛型&lt;/h3>
&lt;h3 id="1032自动装箱拆箱与遍历循环">10.3.2　自动装箱、拆箱与遍历循环&lt;/h3>
&lt;h3 id="1033条件编译">10.3.3　条件编译&lt;/h3></description></item><item><title>第8章　虚拟机字节码执行引擎</title><link>https://yzlc.github.io/post/read/jvm/8/</link><pubDate>Mon, 01 Jun 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/jvm/8/</guid><description>&lt;h2 id="82运行时栈帧结构">8.2　运行时栈帧结构&lt;/h2>
&lt;p>Java虚拟机以方法作为最基本的执行单元&lt;/p>
&lt;p>栈帧（Stack Frame）:虚拟机进行方法调用和方法执行背后的数据结构，也是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程&lt;/p>
&lt;p>一个栈帧需要分配多少内存，并不会受到程序运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式&lt;/p>
&lt;p>当前栈帧（Current Stack Frame）:只有位于栈顶的方法才是在运行的，与这个栈帧所关联的方法被称为“当前方法”（Current Method）。执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作&lt;/p>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/jvm/8-1.jpg"
loading="lazy"
>&lt;/p>
&lt;h3 id="821局部变量表local-variables-table">8.2.1　局部变量表（Local Variables Table）&lt;/h3>
&lt;blockquote>
&lt;p>存放方法参数和方法内部定义的局部变量,Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量&lt;/p>
&lt;/blockquote>
&lt;h3 id="822操作数栈operand-stack">8.2.2　操作数栈（Operand Stack）&lt;/h3>
&lt;blockquote>
&lt;p>后入先出（Last In First Out，LIFO）栈。同局部变量表一样，操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中。32位数据类型所占的栈容量为1，64位所占的栈容量为2。Javac编译器的数据流分析工作保证操作数栈的深度不会超过max_stacks最大值&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/jvm/8-2.jpg"
loading="lazy"
>&lt;/p>
&lt;h3 id="823动态连接dynamic-linking">8.2.3　动态连接（Dynamic Linking）&lt;/h3>
&lt;blockquote>
&lt;p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。另外一部分将在每一次运行期间都转化为直接引用，这部分就称为动态连接&lt;/p>
&lt;/blockquote>
&lt;h3 id="824方法返回地址">8.2.4　方法返回地址&lt;/h3>
&lt;blockquote>
&lt;p>方法正常退出时，主调方法的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中就一般不会保存这部分信息。方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等&lt;/p>
&lt;/blockquote>
&lt;h3 id="825附加信息">8.2.5　附加信息&lt;/h3>
&lt;blockquote>
&lt;p>《Java虚拟机规范》允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试、性能收集相关的信息&lt;/p>
&lt;/blockquote>
&lt;h2 id="83方法调用">8.3　方法调用&lt;/h2>
&lt;h3 id="831解析resolution">8.3.1　解析（Resolution）&lt;/h3>
&lt;blockquote>
&lt;p>调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为解析(主要有静态方法和私有方法两大类)&lt;/p>
&lt;/blockquote>
&lt;p>调用指令&lt;/p>
&lt;ul>
&lt;li>invokestatic。用于调用静态方法&lt;/li>
&lt;li>invokespecial。用于调用实例构造器&lt;!-- raw HTML omitted -->()方法、私有方法和父类中的方法&lt;/li>
&lt;li>invokevirtual。用于调用所有的虚方法&lt;/li>
&lt;li>invokeinterface。用于调用接口方法，会在运行时再确定一个实现该接口的对象&lt;/li>
&lt;li>invokedynamic。先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。前面4条调用指令，分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的&lt;/li>
&lt;/ul>
&lt;p>非虚方法（Non-Virtual Method）&lt;/p>
&lt;ul>
&lt;li>能被invokestatic和invokespecial指令调用，可以在解析阶段中确定唯一的调用版本,在类加载的时候就可以把符号引用解析为该方法的直接引用&lt;/li>
&lt;li>静态方法、私有方法、实例构造器、父类方法、被final修饰的方法(invokevirtual)&lt;/li>
&lt;/ul>
&lt;h3 id="832分派dispatch">8.3.2　分派（Dispatch）&lt;/h3>
&lt;h4 id="1静态分派">1.静态分派&lt;/h4>
&lt;blockquote>
&lt;p>依赖静态类型来决定方法执行版本。最典型应用表现就是方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的&lt;/p>
&lt;/blockquote>
&lt;h4 id="2动态分派">2.动态分派&lt;/h4>
&lt;blockquote>
&lt;p>在运行期根据实际类型确定方法执行版本.表现为方法重写&lt;/p>
&lt;/blockquote>
&lt;p>invokevirtual指令的运行时解析过程&lt;/p>
&lt;ol>
&lt;li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C&lt;/li>
&lt;li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回java.lang.IllegalAccessError异常&lt;/li>
&lt;li>否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程&lt;/li>
&lt;li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常&lt;/li>
&lt;/ol>
&lt;p>字段没有多态性: 字段不使用invokevirtual指令。哪个类的方法访问某个名字的字段时，该名字指的就是这个类能看到的那个字段&lt;/p>
&lt;h4 id="3单分派与多分派">3.单分派与多分派&lt;/h4>
&lt;blockquote>
&lt;p>方法的接收者与方法的参数统称为方法的宗量，根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。Java语言是一门静态多分派、动态单分派的语言&lt;/p>
&lt;/blockquote>
&lt;h4 id="4虚拟机动态分派的实现">4.虚拟机动态分派的实现&lt;/h4>
&lt;blockquote>
&lt;p>使用虚方法表索引来代替元数据查找以提高性能&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/jvm/8-3.jpg"
loading="lazy"
>&lt;/p>
&lt;h2 id="84动态类型语言支持">8.4　动态类型语言支持&lt;/h2>
&lt;h3 id="841动态类型语言">8.4.1　动态类型语言&lt;/h3>
&lt;blockquote>
&lt;p>动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期进行的，JavaScript、Python等。在编译期就进行类型检查过程的语言，譬如C++和Java等就是最常用的静态类型语言&lt;/p>
&lt;/blockquote>
&lt;h3 id="842java与动态类型">8.4.2　Java与动态类型&lt;/h3>
&lt;h3 id="843javalanginvoke包">8.4.3　java.lang.invoke包&lt;/h3>
&lt;blockquote>
&lt;p>提供一种新的动态确定目标方法的机制 - 方法句柄（Method Handle）&lt;/p>
&lt;/blockquote>
&lt;h3 id="844invokedynamic指令">8.4.4　invokedynamic指令&lt;/h3>
&lt;h2 id="85基于栈的字节码解释执行引擎">8.5　基于栈的字节码解释执行引擎&lt;/h2>
&lt;h3 id="851解释执行">8.5.1　解释执行&lt;/h3>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/jvm/8-4.jpg"
loading="lazy"
>&lt;/p>
&lt;h3 id="852基于栈的指令集与基于寄存器的指令集">8.5.2　基于栈的指令集与基于寄存器的指令集&lt;/h3>
&lt;blockquote>
&lt;p>Javac编译器输出的字节码指令流，基本上是一种基于栈的指令集架构（Instruction Set Architecture，ISA），字节码指令流里面的指令大部分都是零地址指令，它们依赖操作数栈进行工作。与之相对的另外一套常用的指令集架构是基于寄存器的指令集，最典型的就是x86的二地址指令集，如果说得更通俗一些就是现在我们主流PC机中物理硬件直接支持的指令集架构，这些指令依赖寄存器进行工作&lt;/p>
&lt;/blockquote>
&lt;p>基于栈的指令集&lt;/p>
&lt;ul>
&lt;li>可移植&lt;/li>
&lt;li>代码相对更加紧凑、编译器实现更加简单&lt;/li>
&lt;li>执行速度稍慢&lt;/li>
&lt;/ul>
&lt;h3 id="853基于栈的解释器执行过程">8.5.3　基于栈的解释器执行过程&lt;/h3></description></item><item><title>第7章　虚拟机类加载机制</title><link>https://yzlc.github.io/post/read/jvm/7/</link><pubDate>Wed, 27 May 2020 11:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/jvm/7/</guid><description>&lt;h2 id="72-类加载的时机">7.2 类加载的时机&lt;/h2>
&lt;blockquote>
&lt;p>加载（Loading）-&amp;gt;连接（Linking）[验证（Verification）-&amp;gt;准备（Preparation）-&amp;gt;解析（Resolution）]-&amp;gt;初始化（Initialization）-&amp;gt;使用（Using）-&amp;gt;卸载（Unloading）&lt;/p>
&lt;/blockquote>
&lt;p>顺序:加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）,这些阶段通常都是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段&lt;/p>
&lt;p>初始化有且仅有6种情况:&lt;/p>
&lt;ol>
&lt;li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：
&lt;ul>
&lt;li>使用new关键字实例化对象的时候&lt;/li>
&lt;li>读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候&lt;/li>
&lt;li>调用一个类型的静态方法的时候&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化&lt;/li>
&lt;li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化&lt;/li>
&lt;li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类&lt;/li>
&lt;li>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化&lt;/li>
&lt;li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化&lt;/li>
&lt;/ol>
&lt;h2 id="73类加载的过程">7.3　类加载的过程&lt;/h2>
&lt;h3 id="731加载">7.3.1　加载&lt;/h3>
&lt;p>过程&lt;/p>
&lt;ol>
&lt;li>通过一个类的全限定名来获取定义此类的二进制字节流&lt;/li>
&lt;li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构&lt;/li>
&lt;li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口&lt;/li>
&lt;/ol>
&lt;p>非数组类型:既可以使用Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的findClass()或loadClass()方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性&lt;/p>
&lt;p>数组类型:数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（Element Type，去掉所有维度）最终还是要靠类加载器来完成加载，一个数组类（简称C）创建过程遵循以下规则：&lt;/p>
&lt;ul>
&lt;li>组件类型（Component Type，去掉一个维度）是引用类型:递归采用加载过程去加载这个组件类型，数组C将被标识在加载该组件类型的类加载器的类名称空间上&lt;/li>
&lt;li>组件类型不是引用类型:Java虚拟机将会把数组C标记为与引导类加载器关联&lt;/li>
&lt;li>数组类的可访问性与它的组件类型的可访问性一致:如果组件类型不是引用类型，它的数组类的可访问性将默认为public，可被所有的类和接口访问到&lt;/li>
&lt;/ul>
&lt;p>加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了。类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口&lt;/p>
&lt;p>加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部分，这两个阶段的开始时间仍然保持着固定的先后顺序&lt;/p>
&lt;h3 id="732验证">7.3.2　验证&lt;/h3>
&lt;blockquote>
&lt;p>确保Class文件的字节流中包含的信息符合《Java虚拟机规范》，被当作代码运行后不会危害虚拟机自身的安全&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>文件格式验证&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>是否以魔数0xCAFEBABE开头&lt;/li>
&lt;li>主、次版本号是否在当前Java虚拟机接受范围内&lt;/li>
&lt;li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）&lt;/li>
&lt;li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。&lt;/li>
&lt;li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。&lt;/li>
&lt;li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>元数据验证&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。&lt;/li>
&lt;li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。&lt;/li>
&lt;li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。&lt;/li>
&lt;li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。&lt;/li>
&lt;li>……&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>字节码验证&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>最复杂的阶段，主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型校验完毕以后，这阶段就要对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况。&lt;/li>
&lt;li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上。&lt;/li>
&lt;li>保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。&lt;/li>
&lt;li>……&lt;/li>
&lt;/ul>
&lt;ol start="4">
&lt;li>符号引用验证&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>符号引用中通过字符串描述的全限定名是否能找到对应的类。&lt;/li>
&lt;li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。&lt;/li>
&lt;li>符号引用中的类、字段、方法的可访问性（private、protected、public、&lt;!-- raw HTML omitted -->）是否可被当
前类访问。&lt;/li>
&lt;li>……&lt;/li>
&lt;/ul>
&lt;h3 id="733准备">7.3.3　准备&lt;/h3>
&lt;blockquote>
&lt;p>为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段&lt;/p>
&lt;/blockquote>
&lt;p>基本数据类型的零值&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>数据类型&lt;/th>
&lt;th>零值&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>int&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>long&lt;/td>
&lt;td>0L&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>short&lt;/td>
&lt;td>(short)0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>char&lt;/td>
&lt;td>&amp;lsquo;\u0000&amp;rsquo;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>byte&lt;/td>
&lt;td>(byte)0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>boolean&lt;/td>
&lt;td>false&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>float&lt;/td>
&lt;td>0.0f&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>double&lt;/td>
&lt;td>0.0d&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>reference&lt;/td>
&lt;td>null&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="734--解析">7.3.4 解析&lt;/h3>
&lt;blockquote>
&lt;p>将常量池内的符号引用替换为直接引用的过程&lt;/p>
&lt;/blockquote>
&lt;p>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中&lt;/p>
&lt;p>直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在&lt;/p>
&lt;ol>
&lt;li>类或接口的解析&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要包括以下3个步骤：&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就将宣告失败&lt;/li>
&lt;li>如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“[Ljava/lang/Integer”的形式，那将会按照第一点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表该数组维度和元素的数组对象&lt;/li>
&lt;li>如果上面两步没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常&lt;/li>
&lt;li>字段解析&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>首先对字段表内class_index项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。解析完成把这个字段所属的类或接口用C表示，《Java虚拟机规范》要求按照如下步骤对C进行后续字段的搜索：&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束&lt;/li>
&lt;li>否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束&lt;/li>
&lt;li>否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束&lt;/li>
&lt;li>否则，查找失败，抛出java.lang.NoSuchFieldError异常&lt;/li>
&lt;li>方法解析&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>先解析出方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，那么我们依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的方法搜索：&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>由于Class文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的，如果在类的方法表中发现class_index中索引的C是个接口的话，那就直接抛出java.lang.IncompatibleClassChangeError异常&lt;/li>
&lt;li>如果通过了第一步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束&lt;/li>
&lt;li>否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束&lt;/li>
&lt;li>否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时候查找结束，抛出java.lang.AbstractMethodError异常&lt;/li>
&lt;li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError&lt;/li>
&lt;li>接口方法解析&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索：&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>与类的方法解析相反，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那么就直接抛出java.lang.IncompatibleClassChangeError异常&lt;/li>
&lt;li>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束&lt;/li>
&lt;li>否则，在接口C的父接口中递归查找，直到java.lang.Object类（接口方法的查找范围也会包括Object类中的方法）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束&lt;/li>
&lt;li>对于规则3，由于Java的接口允许多重继承，如果C的不同父接口中存有多个简单名称和描述符都与目标相匹配的方法，那将会从这多个方法中返回其中一个并结束查找，《Java虚拟机规范》中并没有进一步规则约束应该返回哪一个接口方法。但与之前字段查找类似地，不同发行商实现的Javac编译器有可能会按照更严格的约束拒绝编译这种代码来避免不确定性&lt;/li>
&lt;li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常&lt;/li>
&lt;/ol>
&lt;h3 id="735初始化">7.3.5　初始化&lt;/h3>
&lt;blockquote>
&lt;p>初始化阶段就是执行类构造器&lt;!-- raw HTML omitted -->()方法的过程&lt;/p>
&lt;/blockquote>
&lt;p>&lt;!-- raw HTML omitted -->()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->()方法与类的构造函数（即在虚拟机视角中的实例构造器&lt;!-- raw HTML omitted -->()方法）不同，它不需要显式地调用父类构造器，Java虚拟机会保证在子类的&lt;!-- raw HTML omitted -->()方法执行前，父类的&lt;!-- raw HTML omitted -->()方法已经执行完毕。因此在Java虚拟机中第一个被执行的&lt;!-- raw HTML omitted -->()方法的类型肯定是java.lang.Object&lt;/p>
&lt;p>由于父类的&lt;!-- raw HTML omitted -->()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成&lt;!-- raw HTML omitted -->()方法&lt;/p>
&lt;p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成&lt;!-- raw HTML omitted -->()方法。但接口与类不同的是，执行接口的&lt;!-- raw HTML omitted -->()方法不需要先执行父接口的&lt;!-- raw HTML omitted -->()方法，因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也一样不会执行接口的&lt;!-- raw HTML omitted -->()方法&lt;/p>
&lt;p>Java虚拟机必须保证一个类的&lt;!-- raw HTML omitted -->()方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的&lt;!-- raw HTML omitted -->()方法，其他线程都需要阻塞等待，直到活动线程执行完毕&lt;!-- raw HTML omitted -->()方法。如果在一个类的&lt;!-- raw HTML omitted -->()方法中有耗时很长的操作，那就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的&lt;/p>
&lt;h2 id="74类加载器">7.4　类加载器&lt;/h2>
&lt;h3 id="741类与类加载器">7.4.1　类与类加载器&lt;/h3>
&lt;blockquote>
&lt;p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。类加载器不同，那这两个类就必定不相等(equals()、isAssignableFrom()、isInstance()、instanceof)&lt;/p>
&lt;/blockquote>
&lt;h3 id="742双亲委派模型parents-delegation-model">7.4.2　双亲委派模型（Parents Delegation Model）&lt;/h3>
&lt;blockquote>
&lt;p>除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器&lt;/p>
&lt;/blockquote>
&lt;p>启动类加载器（Bootstrap Class Loader）：负责加载存放在&amp;lt;JAVA_HOME&amp;gt;\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的（按照文件名识别，如rt.jar、tools.jar）类库加载到虚拟机的内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，那直接使用null代替即可&lt;/p>
&lt;p>扩展类加载器（Extension Class Loader）：这个类加载器是在类sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的。它负责加载&amp;lt;JAVA_HOME&amp;gt;\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。根据“扩展类加载器”这个名称，就可以推断出这是一种Java系统类库的扩展机制，JDK的开发团队允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能，在JDK9之后被模块化带来的天然扩展能力取代。由于扩展类加载器是由Java代码实现的，开发者可以直接在程序中使用扩展类加载器来加载Class文件&lt;/p>
&lt;p>应用程序类加载器（Application Class Loader）：这个类加载器由sun.misc.Launcher$AppClassLoader来实现。由于应用程序类加载器是ClassLoader类中的getSystem-ClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。是程序中默认的类加载器
&lt;img src="https://yzlc.github.io/images/read/jvm/7-2.jpg"
loading="lazy"
>&lt;/p>
&lt;h3 id="743破坏双亲委派模型">7.4.3　破坏双亲委派模型&lt;/h3>
&lt;h2 id="75java模块化系统">7.5　Java模块化系统&lt;/h2>
&lt;h3 id="751模块的兼容性">7.5.1　模块的兼容性&lt;/h3>
&lt;h3 id="752模块化下的类加载器">7.5.2　模块化下的类加载器&lt;/h3>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/jvm/7-7.jpg"
loading="lazy"
>&lt;/p></description></item><item><title>6.4　字节码指令简介</title><link>https://yzlc.github.io/post/read/jvm/6.4/</link><pubDate>Wed, 27 May 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/jvm/6.4/</guid><description>&lt;h3 id="641字节码与数据类型">6.4.1　字节码与数据类型&lt;/h3>
&lt;blockquote>
&lt;p>编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为相应的int类型数据，将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据。因此，大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的对int类型作为运算类型（Computational Type）来进行的&lt;/p>
&lt;/blockquote>
&lt;p>Java虚拟机指令集所支持的数据类型&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>opcode&lt;/th>
&lt;th>byte&lt;/th>
&lt;th>short&lt;/th>
&lt;th>int&lt;/th>
&lt;th>long&lt;/th>
&lt;th>float&lt;/th>
&lt;th>double&lt;/th>
&lt;th>char&lt;/th>
&lt;th>reference&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Tipush&lt;/td>
&lt;td>bipush&lt;/td>
&lt;td>sipush&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tconst&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>iconst&lt;/td>
&lt;td>lconst&lt;/td>
&lt;td>fconst&lt;/td>
&lt;td>dconst&lt;/td>
&lt;td>&lt;/td>
&lt;td>aconst&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tload&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>iload&lt;/td>
&lt;td>lload&lt;/td>
&lt;td>fload&lt;/td>
&lt;td>dload&lt;/td>
&lt;td>&lt;/td>
&lt;td>aload&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tstore&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>istore&lt;/td>
&lt;td>lstore&lt;/td>
&lt;td>fstore&lt;/td>
&lt;td>dstore&lt;/td>
&lt;td>&lt;/td>
&lt;td>astore&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tinc&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>iinc&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Taload&lt;/td>
&lt;td>baload&lt;/td>
&lt;td>saload&lt;/td>
&lt;td>iaload&lt;/td>
&lt;td>laload&lt;/td>
&lt;td>faload&lt;/td>
&lt;td>daload&lt;/td>
&lt;td>caload&lt;/td>
&lt;td>aaload&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tastore&lt;/td>
&lt;td>bastore&lt;/td>
&lt;td>sastore&lt;/td>
&lt;td>iastore&lt;/td>
&lt;td>lastore&lt;/td>
&lt;td>fastore&lt;/td>
&lt;td>dastore&lt;/td>
&lt;td>castore&lt;/td>
&lt;td>aastore&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tadd&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>iadd&lt;/td>
&lt;td>ladd&lt;/td>
&lt;td>fadd&lt;/td>
&lt;td>dadd&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tsub&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>isub&lt;/td>
&lt;td>lsub&lt;/td>
&lt;td>fsub&lt;/td>
&lt;td>dsub&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tmul&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>imul&lt;/td>
&lt;td>lmul&lt;/td>
&lt;td>fmul&lt;/td>
&lt;td>dmul&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tdiv&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>idiv&lt;/td>
&lt;td>ldiv&lt;/td>
&lt;td>fdiv&lt;/td>
&lt;td>ddiv&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Trem&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>irem&lt;/td>
&lt;td>lrem&lt;/td>
&lt;td>frem&lt;/td>
&lt;td>drem&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tneg&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>ineg&lt;/td>
&lt;td>lneg&lt;/td>
&lt;td>fneg&lt;/td>
&lt;td>dneg&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tshl&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>ishl&lt;/td>
&lt;td>lshl&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tshr&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>ishr&lt;/td>
&lt;td>lshr&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tushr&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>iushr&lt;/td>
&lt;td>lushr&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tand&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>iand&lt;/td>
&lt;td>land&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tor&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>ior&lt;/td>
&lt;td>lor&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Txor&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>ixor&lt;/td>
&lt;td>lxor&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>i2T&lt;/td>
&lt;td>i2b&lt;/td>
&lt;td>i2s&lt;/td>
&lt;td>&lt;/td>
&lt;td>i2l&lt;/td>
&lt;td>i2f&lt;/td>
&lt;td>i2d&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>l2T&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>l2i&lt;/td>
&lt;td>&lt;/td>
&lt;td>l2f&lt;/td>
&lt;td>l2d&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>f2T&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>f2i&lt;/td>
&lt;td>f2l&lt;/td>
&lt;td>&lt;/td>
&lt;td>f2d&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>d2T&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>d2i&lt;/td>
&lt;td>d2l&lt;/td>
&lt;td>d2f&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tcmp&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>lcmp&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tcmp1&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>fcmpl&lt;/td>
&lt;td>dcmpl&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tcmpg&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>fcmpg&lt;/td>
&lt;td>dcmpg&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>if_TcmpOP&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>if_icmpOP&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>if_acmpOP&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Treturn&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>ireturn&lt;/td>
&lt;td>lreturn&lt;/td>
&lt;td>freturn&lt;/td>
&lt;td>dreturn&lt;/td>
&lt;td>&lt;/td>
&lt;td>areturn&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="642加载和存储指令">6.4.2　加载和存储指令&lt;/h3>
&lt;blockquote>
&lt;p>加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输&lt;/p>
&lt;/blockquote>
&lt;p>将一个局部变量加载到操作栈：iload、iload_&lt;!-- raw HTML omitted -->、lload、lload_&lt;!-- raw HTML omitted -->、fload、fload_&lt;!-- raw HTML omitted -->、dload、dload_&lt;!-- raw HTML omitted -->、aload、aload_&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>将一个数值从操作数栈存储到局部变量表：istore、istore_&lt;!-- raw HTML omitted -->、lstore、lstore_&lt;!-- raw HTML omitted -->、fstore、fstore_&lt;!-- raw HTML omitted -->、dstore、dstore_&lt;!-- raw HTML omitted -->、astore、astore_&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_&lt;!-- raw HTML omitted -->、lconst_&lt;!-- raw HTML omitted -->、fconst_&lt;!-- raw HTML omitted -->、dconst_&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>扩充局部变量表的访问索引的指令：wide&lt;/p>
&lt;h3 id="643运算指令">6.4.3　运算指令&lt;/h3>
&lt;blockquote>
&lt;p>对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶.遵循IEEE754规范&lt;/p>
&lt;/blockquote>
&lt;p>加法指令：iadd、ladd、fadd、dadd&lt;/p>
&lt;p>减法指令：isub、lsub、fsub、dsub&lt;/p>
&lt;p>乘法指令：imul、lmul、fmul、dmul&lt;/p>
&lt;p>除法指令：idiv、ldiv、fdiv、ddiv&lt;/p>
&lt;p>求余指令：irem、lrem、frem、drem&lt;/p>
&lt;p>取反指令：ineg、lneg、fneg、dneg&lt;/p>
&lt;p>位移指令：ishl、ishr、iushr、lshl、lshr、lushr&lt;/p>
&lt;p>按位或指令：ior、lor&lt;/p>
&lt;p>按位与指令：iand、land&lt;/p>
&lt;p>按位异或指令：ixor、lxor&lt;/p>
&lt;p>局部变量自增指令：iinc&lt;/p>
&lt;p>比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp&lt;/p>
&lt;h3 id="644类型转换指令">6.4.4　类型转换指令&lt;/h3>
&lt;p>窄化类型转换（Narrowing Numeric Conversion）必须显式使用转换指令完成，指令包括i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f&lt;/p>
&lt;p>int或long类型窄化为T:丢弃除最低位N(T的数据类型长度)字节以外的内容，可能导致转换结果与输入值有不同的正负号&lt;/p>
&lt;p>浮点值窄化转换为T（T限于int或long）：&lt;/p>
&lt;ul>
&lt;li>如果浮点值是NaN，那转换结果就是int或long类型的0&lt;/li>
&lt;li>如果浮点值不是无穷大的话，浮点值使用IEEE 754的向零舍入模式取整，获得整数值v。如果v在目标类型T（int或long）的表示范围之类，那转换结果就是v；否则，将根据v的符号，转换为T所能表示的最大或者最小正数&lt;/li>
&lt;/ul>
&lt;h3 id="645对象创建与访问指令">6.4.5　对象创建与访问指令&lt;/h3>
&lt;p>创建类实例的指令：new&lt;/p>
&lt;p>创建数组的指令：newarray、anewarray、multianewarray&lt;/p>
&lt;p>访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield、getstatic、putstatic&lt;/p>
&lt;p>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload&lt;/p>
&lt;p>将一个操作数栈的值储存到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore&lt;/p>
&lt;p>取数组长度的指令：arraylength&lt;/p>
&lt;p>检查类实例类型的指令：instanceof、checkcast&lt;/p>
&lt;h3 id="646操作数栈管理指令">6.4.6　操作数栈管理指令&lt;/h3>
&lt;p>将操作数栈的栈顶一个或两个元素出栈：pop、pop2&lt;/p>
&lt;p>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2&lt;/p>
&lt;p>将栈最顶端的两个数值互换：swap&lt;/p>
&lt;h3 id="647控制转移指令">6.4.7　控制转移指令&lt;/h3>
&lt;blockquote>
&lt;p>让Java虚拟机有条件或无条件地从指定位置指令（而不是控制转移指令）的下一条指令继续执行程序，从概念模型上理解，可以认为控制指令就是在有条件或无条件地修改PC寄存器的值&lt;/p>
&lt;/blockquote>
&lt;p>条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne&lt;/p>
&lt;p>复合条件分支：tableswitch、lookupswitch&lt;/p>
&lt;p>无条件分支：goto、goto_w、jsr、jsr_w、ret&lt;/p>
&lt;h3 id="648方法调用和返回指令">6.4.8　方法调用和返回指令&lt;/h3>
&lt;p>方法调用&lt;/p>
&lt;ul>
&lt;li>invokevirtual指令：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式&lt;/li>
&lt;li>invokeinterface指令：用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用&lt;/li>
&lt;li>invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法&lt;/li>
&lt;li>invokestatic指令：用于调用类静态方法（static方法）&lt;/li>
&lt;li>invokedynamic指令：用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法。前面四条调用指令的分派逻辑都固化在Java虚拟机内部，用户无法改变，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的&lt;/li>
&lt;/ul>
&lt;p>方法返回指令:根据返回值的类型区分，包括ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn，另外还有一条return指令供声明为void的方法、实例初始化方法、类和接口的类初始化方法使用&lt;/p>
&lt;h3 id="649异常处理指令">6.4.9　异常处理指令&lt;/h3>
&lt;blockquote>
&lt;p>由athrow指令实现,许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出.采用异常表完成&lt;/p>
&lt;/blockquote>
&lt;h3 id="6410同步指令">6.4.10　同步指令&lt;/h3>
&lt;blockquote>
&lt;p>使用管程（Monitor，更常见的是直接将它称为“锁”）实现方法级的同步:检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程同步一段指令集序列:monitorenter和monitorexit两条指令&lt;/p>
&lt;/blockquote></description></item><item><title>6.3　Class类文件的结构</title><link>https://yzlc.github.io/post/read/jvm/6.3/</link><pubDate>Thu, 14 May 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/jvm/6.3/</guid><description>&lt;blockquote>
&lt;p>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8个字节进行存储&lt;/p>
&lt;/blockquote>
&lt;p>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表”&lt;/p>
&lt;ul>
&lt;li>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值&lt;/li>
&lt;li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表，这张表由表6-1所示的数据项按严格顺序排列构成&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>名称&lt;/th>
&lt;th>数量&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>u4&lt;/td>
&lt;td>magic&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>minor_version&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>major_version&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>constant_pool_count&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cp_info&lt;/td>
&lt;td>constant_pool&lt;/td>
&lt;td>constant_pool_count-1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>access_flags&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>this_class&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>super_class&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>interfaces_count&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>interfaces&lt;/td>
&lt;td>interfaces_count&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>fields_count&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>field_info&lt;/td>
&lt;td>fields&lt;/td>
&lt;td>fields_count&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>methods_count&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>method_info&lt;/td>
&lt;td>methods&lt;/td>
&lt;td>methods_count&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>attributes_count&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>attribute_info&lt;/td>
&lt;td>attributes&lt;/td>
&lt;td>attributes_count&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="631魔数与class文件的版本">6.3.1　魔数与Class文件的版本&lt;/h3>
&lt;p>魔数（Magic Number）:值为0xCAFEBABE.每个Class文件的头4个字节,确定这个文件是否为一个能被虚拟机接受的Class文件&lt;/p>
&lt;p>版本:紧接着魔数的4个字节存储,第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。Java版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1，高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，因为《Java虚拟机规范》在Class文件校验部分明确要求了即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件
&lt;img src="https://yzlc.github.io/images/read/jvm/6-2.jpg"
loading="lazy"
>&lt;/p>
&lt;h3 id="632常量池">6.3.2　常量池&lt;/h3>
&lt;blockquote>
&lt;p>紧接着主、次版本号之后的是常量池入口，常量池可以比喻为Class文件里的资源仓库，它是Class文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一，另外，它还是在Class文件中第一个出现的表类型数据项目&lt;/p>
&lt;/blockquote>
&lt;p>常量池容量计数值（constant_pool_count）: 常量池入口放置的一项u2类型的数据,因为常量池中常量的数量是不固定的&lt;/p>
&lt;ul>
&lt;li>容量计数从1而不是0开始的，如图6-3所示，常量池容量为十六进制数0x0016，即十进制的22，这就代表常量池中有21项常量，索引值范围为1～21
&lt;img src="https://yzlc.github.io/images/read/jvm/6-3.jpg"
loading="lazy"
>&lt;/li>
&lt;li>第0项常量: 某些指向常量池的索引值的数据在表达“不引用任何一个常量池项目”的含义，可以把索引值设置为0来表示&lt;/li>
&lt;/ul>
&lt;h4 id="主要存放两大类常量">主要存放两大类常量&lt;/h4>
&lt;p>字面量（Literal）: 接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等&lt;/p>
&lt;p>符号引用（Symbolic References）: 属于编译原理方面的概念，主要包括下面几类常量：&lt;/p>
&lt;ul>
&lt;li>被模块导出或者开放的包（Package）&lt;/li>
&lt;li>类和接口的全限定名（Fully Qualified Name）&lt;/li>
&lt;li>字段的名称和描述符（Descriptor）&lt;/li>
&lt;li>方法的名称和描述符&lt;/li>
&lt;li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）&lt;/li>
&lt;li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）&lt;/li>
&lt;/ul>
&lt;h4 id="常量表">常量表&lt;/h4>
&lt;blockquote>
&lt;p>常量池中每一项常量都是一个表&lt;/p>
&lt;/blockquote>
&lt;p>常量类型:表结构起始第一位是u1类型的标志位（tag，取值见表中标志列），代表着当前常量属于哪种常量类型&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>常量&lt;/th>
&lt;th>项目&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>CONSTANT_Utf8_info&lt;/td>
&lt;td>tag&lt;/td>
&lt;td>u1&lt;/td>
&lt;td>值为1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>length&lt;/td>
&lt;td>u2&lt;/td>
&lt;td>UTF-8编码的字符串占用了字节数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>bytes&lt;/td>
&lt;td>u1&lt;/td>
&lt;td>长度length的UTF-8编码的字符串&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CONSTANT_Integer_info&lt;/td>
&lt;td>tag&lt;/td>
&lt;td>u1&lt;/td>
&lt;td>值为3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>bytes&lt;/td>
&lt;td>u4&lt;/td>
&lt;td>按照高位在前存储的int值&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CONSTANT_Float_info&lt;/td>
&lt;td>tag&lt;/td>
&lt;td>u1&lt;/td>
&lt;td>值为4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>bytes&lt;/td>
&lt;td>u4&lt;/td>
&lt;td>按照高位在前存储的float值&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CONSTANT_Long_info&lt;/td>
&lt;td>tag&lt;/td>
&lt;td>u1&lt;/td>
&lt;td>值为5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>bytes&lt;/td>
&lt;td>u8&lt;/td>
&lt;td>按照高位在前存储的long值&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CONSTANT_Double_info&lt;/td>
&lt;td>tag&lt;/td>
&lt;td>u1&lt;/td>
&lt;td>值为6&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>bytes&lt;/td>
&lt;td>u8&lt;/td>
&lt;td>按照高位在前存储的double值&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CONSTANT_Class_info&lt;/td>
&lt;td>tag&lt;/td>
&lt;td>u1&lt;/td>
&lt;td>值为7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>index&lt;/td>
&lt;td>u2&lt;/td>
&lt;td>指向全限定名常量项的索引&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CONSTANT_String_info&lt;/td>
&lt;td>tag&lt;/td>
&lt;td>u1&lt;/td>
&lt;td>值为8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>index&lt;/td>
&lt;td>u2&lt;/td>
&lt;td>指向字符串字面量的索引的索引&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CONSTANT_Fieldref_info&lt;/td>
&lt;td>tag&lt;/td>
&lt;td>u1&lt;/td>
&lt;td>值为9&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>index&lt;/td>
&lt;td>u2&lt;/td>
&lt;td>指向声明字段的类或者接口描述符CONSTANT_Class_info的索引项&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>index&lt;/td>
&lt;td>u2&lt;/td>
&lt;td>指向字段描述符CONSTANT_NameAndType的索引项&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CONSTANT_Methodref_info&lt;/td>
&lt;td>tag&lt;/td>
&lt;td>u1&lt;/td>
&lt;td>值为10&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>index&lt;/td>
&lt;td>u2&lt;/td>
&lt;td>指向声明方法的类描述符CONSTANT_Class_info的索引项&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>index&lt;/td>
&lt;td>u2&lt;/td>
&lt;td>指向名称及类型描述符CONSTANT_NameAndType的索引项&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CONSTANT_InterfaceMethodref_info&lt;/td>
&lt;td>tag&lt;/td>
&lt;td>u1&lt;/td>
&lt;td>值为11&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>index&lt;/td>
&lt;td>u2&lt;/td>
&lt;td>指向声明方法的接口描述符CONSTANT_Class_info的索引项&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>index&lt;/td>
&lt;td>u2&lt;/td>
&lt;td>指向名称及类型描述符CONSTANT_NameAndType的索引项&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CONSTANT_NameAndType_info&lt;/td>
&lt;td>tag&lt;/td>
&lt;td>u1&lt;/td>
&lt;td>值为12&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>index&lt;/td>
&lt;td>u2&lt;/td>
&lt;td>指向该字段或方法名称常量项的索引&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>index&lt;/td>
&lt;td>u2&lt;/td>
&lt;td>指向该字段或方法描述符常量项的索引&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CONSTANT_MethodHandle_info&lt;/td>
&lt;td>tag&lt;/td>
&lt;td>u1&lt;/td>
&lt;td>值为15&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>reference_kind&lt;/td>
&lt;td>u1&lt;/td>
&lt;td>值必须在1至9之间(包括1和9),它决定了方法句柄的类型.方法句柄的值表示方法句柄的字节码行为&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>reference_index&lt;/td>
&lt;td>u2&lt;/td>
&lt;td>值必须是对常量池的有效索引&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CONSTANT_MethodType_info&lt;/td>
&lt;td>tag&lt;/td>
&lt;td>u1&lt;/td>
&lt;td>值为16&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>descriptor_index&lt;/td>
&lt;td>u2&lt;/td>
&lt;td>值必须是对常量池的有效索引,常量池在该索引处的项必须是CONSTANT_Utf8_info结构,表示方法的描述符&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CONSTANT_Dynamic_info&lt;/td>
&lt;td>tag&lt;/td>
&lt;td>u1&lt;/td>
&lt;td>值为17&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>bootstrap_method_attr_index&lt;/td>
&lt;td>u2&lt;/td>
&lt;td>值必须是对当前Class文件中引导方法表的bootstrap_mathods[]数组的有效索引&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>name_and_type_index&lt;/td>
&lt;td>u2&lt;/td>
&lt;td>值必须是对当前常量池的有效索引,常量池在该索引处的项必须是CONSTANT_NameAndType_info结构,表示方法名和方法描述符&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CONSTANT_InvokeDynamic_info&lt;/td>
&lt;td>tag&lt;/td>
&lt;td>u1&lt;/td>
&lt;td>值为18&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>bootstrap_method_attr_index&lt;/td>
&lt;td>u2&lt;/td>
&lt;td>值必须是对当前Class文件中引导方法表的bootstrap_mathods[]数组的有效索引&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>name_and_type_index&lt;/td>
&lt;td>u2&lt;/td>
&lt;td>值必须是对当前常量池的有效索引,常量池在该索引处的项必须是CONSTANT_NameAndType_info结构,表示方法名和方法描述符&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CONSTANT_Module_info&lt;/td>
&lt;td>tag&lt;/td>
&lt;td>u1&lt;/td>
&lt;td>值为19&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>name_index&lt;/td>
&lt;td>u2&lt;/td>
&lt;td>值必须是对常量池的有效索引,常量池在该索引处的项必须是CONSTANT_Utf8_info结构,表示模块名字&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CONSTANT_Package_info&lt;/td>
&lt;td>tag&lt;/td>
&lt;td>u1&lt;/td>
&lt;td>值为20&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>name_index&lt;/td>
&lt;td>u2&lt;/td>
&lt;td>值必须是对常量池的有效索引,常量池在该索引处的项必须是CONSTANT_Utf8_info结构,表示包名称&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="633访问标志access_flags">6.3.3　访问标志(access_flags)&lt;/h3>
&lt;blockquote>
&lt;p>常量池紧接着的2个字节,用于识别一些类或者接口层次的访问信息,包括:这个Class是类还是接口;是否定义为public;是否定义为abstract;类是否被声明为final等等&lt;/p>
&lt;/blockquote>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>标志名称&lt;/th>
&lt;th>标志值&lt;/th>
&lt;th>含义&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>ACC_PUBLIC&lt;/td>
&lt;td>0x0001&lt;/td>
&lt;td>是否为public类型&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ACC_FINAL&lt;/td>
&lt;td>0x0010&lt;/td>
&lt;td>是否被声明为final,只有类可设置&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ACC_SUPER&lt;/td>
&lt;td>0x0020&lt;/td>
&lt;td>是否允许使用invokespecial字节码指令的新语义,invokespecial指令的语义在JDK1.0.2发生过改变,为了区别这条指令使用哪种语义,JDK1.0.2之后编译出来的类的这个标志都必须为真&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ACC_INTERFACE&lt;/td>
&lt;td>0x0200&lt;/td>
&lt;td>标识这是一个接口&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ACC_ABSTRACT&lt;/td>
&lt;td>0x0400&lt;/td>
&lt;td>是否为abstract类型,对于接口或者抽象类来说,此标志为真,其他类型值为假&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ACC_SYNTHETIC&lt;/td>
&lt;td>0x1000&lt;/td>
&lt;td>标识这个类并非由用户代码产生的&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ACC_ANNOTATION&lt;/td>
&lt;td>0x2000&lt;/td>
&lt;td>标识这是一个注解&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ACC_ENUM&lt;/td>
&lt;td>0x4000&lt;/td>
&lt;td>标识这是一个枚举&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ACC_MODULE&lt;/td>
&lt;td>0x8000&lt;/td>
&lt;td>标识这是一个模块&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="634类索引this_class父类索引super_class与接口索引interfaes集合">6.3.4　类索引(this_class)、父类索引(super_class)与接口索引(interfaes)集合&lt;/h3>
&lt;blockquote>
&lt;p>按顺序排列在访问标志之后,类索引和父类索引都是一个u2类型的数据，而接口索引集合是一组u2类型的数据的集合,Class文件中由这三项数据来确定该类型的继承关系&lt;/p>
&lt;/blockquote>
&lt;p>类索引:确定这个类的全限定名&lt;/p>
&lt;p>父类索引:确定这个类的父类的全限定名&lt;/p>
&lt;ul>
&lt;li>父类索引只有一个(不允许多重继承)&lt;/li>
&lt;li>除了Object，所有的Java类都有父类(父类索引不为0)
&lt;ul>
&lt;li>除了Object，所有的Java类都有父类(父类索引不为0)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>除了Object，所有的Java类都有父类(父类索引不为0)
&lt;ul>
&lt;li>除了Object，所有的Java类都有父类(父类索引不为0)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>除了Object，所有的Java类都有父类(父类索引不为0)&lt;/li>
&lt;/ul>
&lt;p>类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串
&lt;img src="https://yzlc.github.io/images/read/jvm/6-6.jpg"
loading="lazy"
>&lt;/p>
&lt;p>接口索引集合:描述这个类实现了哪些接口，按implements关键字（如果Class文件表示的是接口，则是extends）后的接口顺序从左到右排列在接口索引集合中&lt;/p>
&lt;ul>
&lt;li>入口的第一项u2类型的数据为接口计数器（interfaces_count），表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0，后面接口的索引表不再占用任何字节&lt;/li>
&lt;/ul>
&lt;h3 id="635字段表field_info集合">6.3.5　字段表（field_info）集合&lt;/h3>
&lt;blockquote>
&lt;p>描述接口或者类中声明的变量&lt;/p>
&lt;/blockquote>
&lt;p>字段表结构&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>名称&lt;/th>
&lt;th>数量&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>access_flags&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>name_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>descriptor_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>attributes_count&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>attribute_info&lt;/td>
&lt;td>attributes&lt;/td>
&lt;td>attributes_count&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>字段访问标志&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>标志名称&lt;/th>
&lt;th>标志值&lt;/th>
&lt;th>含义&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>ACC_PUBLIC&lt;/td>
&lt;td>0x0001&lt;/td>
&lt;td>字段是否public&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ACC_PRIVATE&lt;/td>
&lt;td>0x0002&lt;/td>
&lt;td>字段是否private&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ACC_PROTECTED&lt;/td>
&lt;td>0x0004&lt;/td>
&lt;td>字段是否protected&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ACC_STATIC&lt;/td>
&lt;td>0x0008&lt;/td>
&lt;td>字段是否static&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ACC_FINAL&lt;/td>
&lt;td>0x0010&lt;/td>
&lt;td>字段是否final&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ACC_VOLATILE&lt;/td>
&lt;td>0x0040&lt;/td>
&lt;td>字段是否pvolatile&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ACC_TRANSIENT&lt;/td>
&lt;td>0x0080&lt;/td>
&lt;td>字段是否transient&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ACC_SYNTHETIC&lt;/td>
&lt;td>0x1000&lt;/td>
&lt;td>字段是否由编译器自动产生&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ACC_ENUM&lt;/td>
&lt;td>0x4000&lt;/td>
&lt;td>字段是否enum&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>描述符标识字符含义&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>标识字符&lt;/th>
&lt;th>含义&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>B&lt;/td>
&lt;td>基本类型byte&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C&lt;/td>
&lt;td>基本类型char&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>D&lt;/td>
&lt;td>基本类型double&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>F&lt;/td>
&lt;td>基本类型float&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>I&lt;/td>
&lt;td>基本类型int&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>J&lt;/td>
&lt;td>基本类型long&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>S&lt;/td>
&lt;td>基本类型short&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Z&lt;/td>
&lt;td>基本类型boolean&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>V&lt;/td>
&lt;td>特殊类型void&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>L&lt;/td>
&lt;td>对象类型,如Ljava/lang/Object;&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>数组:前置&lt;code>[&lt;/code>,例如&lt;code>String[][]&lt;/code>记录成&lt;code>[[Ljava/lang/String；&lt;/code>;&lt;code>int[]&lt;/code>记录成&lt;code>[I&lt;/code>&lt;/p>
&lt;p>方法:先参数列表(按参数顺序放小括号&lt;code>()&lt;/code>),后返回值.如void inc()描述符为“()V”，方法toString()描述符为“()Ljava/lang/String；”，indexOf(char[]source，int sourceOffset，int sourceCount，char[]target，int targetOffset，int targetCount，int fromIndex)描述符为“([CII[CIII)I&lt;/p>
&lt;h3 id="636方法表集合">6.3.6　方法表集合&lt;/h3>
&lt;blockquote>
&lt;p>同字段表一样，依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）&lt;/p>
&lt;/blockquote>
&lt;p>方法表结构&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>名称&lt;/th>
&lt;th>数量&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>access_flags&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>name_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>descriptor_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>attributes_count&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>attribute_info&lt;/td>
&lt;td>attributes&lt;/td>
&lt;td>attributes_count&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>方法访问标志&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>标志名称&lt;/th>
&lt;th>标志值&lt;/th>
&lt;th>含义&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>ACC_PUBLIC&lt;/td>
&lt;td>0x0001&lt;/td>
&lt;td>方法是否为public&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ACC_PRIVATE&lt;/td>
&lt;td>0x0002&lt;/td>
&lt;td>方法是否为private&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ACC_PROTECTED&lt;/td>
&lt;td>0x0004&lt;/td>
&lt;td>方法是否为protected&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ACC_STATIC&lt;/td>
&lt;td>0x0008&lt;/td>
&lt;td>方法是否为static&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ACC_FINAL&lt;/td>
&lt;td>0x0010&lt;/td>
&lt;td>方法是否为final&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ACC_SYNCHRONIZED&lt;/td>
&lt;td>0x0020&lt;/td>
&lt;td>方法是否为synchronized&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ACC_BRIDGE&lt;/td>
&lt;td>0x0040&lt;/td>
&lt;td>方法是否为编译器产生的桥接方法&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ACC_VARARGS&lt;/td>
&lt;td>0x0080&lt;/td>
&lt;td>方法是否接受不定参数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ACC_NATIVE&lt;/td>
&lt;td>0x0100&lt;/td>
&lt;td>方法是否为native&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ACC_ABSTRACT&lt;/td>
&lt;td>0x0400&lt;/td>
&lt;td>方法是否为abstract&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ACC_STRICT&lt;/td>
&lt;td>0x0800&lt;/td>
&lt;td>方法是否为strictfp&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ACC_SYNTHETIC&lt;/td>
&lt;td>0x1000&lt;/td>
&lt;td>方法是否由编译器自动产生&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="637属性表attribute_info集合">6.3.7　属性表（attribute_info）集合&lt;/h3>
&lt;ol>
&lt;li>Code属性
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>名称&lt;/th>
&lt;th>数量&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>attribute_name_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u4&lt;/td>
&lt;td>attribute_length&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>max_stack&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>max_locals&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u4&lt;/td>
&lt;td>code_length&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u1&lt;/td>
&lt;td>code&lt;/td>
&lt;td>code_length&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>exception_table_length&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>exception_info&lt;/td>
&lt;td>exception_table&lt;/td>
&lt;td>exception_table_length&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>attributes_count&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>attribute_info&lt;/td>
&lt;td>attributes&lt;/td>
&lt;td>attributes_count&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>attribute_name_index:指向CONSTANT_Utf8_info型常量的索引，此常量值固定为“Code”，它代表了该属性的属性名称&lt;/li>
&lt;li>attribute_length:属性值的长度，由于属性名称索引与属性长度一共为6个字节，所以属性值的长度固定为整个属性表长度减去6个字节。&lt;/li>
&lt;li>max_stack:操作数栈（Operand Stack）深度的最大值。虚拟机运行的时候需要根据这个值来分配栈帧（Stack Frame）中的操作栈深度。&lt;/li>
&lt;li>max_locals:局部变量表所需的存储空间。单位是变量槽（Slot）。
&lt;ul>
&lt;li>局部变量表:方法参数（包括实例方法中的隐藏参数“this”）、显式异常处理程序的参数（Exception Handler Parameter，try-catch中catch块定义的异常）、方法体中定义的局部变量&lt;/li>
&lt;li>并不是在方法中用了多少个局部变量，就把这些局部变量所占变量槽数量之和作为max_locals的值，操作数栈和局部变量表直接决定一个该方法的栈帧所耗费的内存，不必要的操作数栈深度和变量槽数量会造成内存的浪费。Java虚拟机的做法是将局
部变量表中的变量槽进行重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的变量槽可以被其他局部变量所使用，Javac编译器会根据变量的作用域来分配变量槽给各个变量使用，根据同时生存的最大局部变量数量和类型计算出max_locals的大小。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>code_length:字节码长度
&lt;ul>
&lt;li>u4类型的长度值，理论上可以达到2的32次幂，《Java虚拟机规范》限制方法不允许超过65535条字节码指令，即它实际只使用了u2的长度。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>code:存储字节码指令的一系列字节流。
&lt;ul>
&lt;li>字节码指令:每个指令就是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以对应找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及后续的参数应当如何解析。一个u1数据类型的取值范围为0x00～0xFF，对应十进制的0～255，也就是一共可以表达256条指令。Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码（Code，方法体里面的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分，那么在整个Class文件里，Code属性用于描述代码，所有的其他数据项目都用于描述元数据。&lt;/li>
&lt;li>异常表:字节码指令之后
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>名称&lt;/th>
&lt;th>数量&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>start_pc&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>end_pc&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>handler_pc&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>catch_type&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>Exceptions属性&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>列举出方法中可能抛出的受查异常(Checked Exceptions),也就是方法描述时在throws关键字后面列举的异常&lt;/p>
&lt;/blockquote>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>名称&lt;/th>
&lt;th>数量&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>attribute_name_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u4&lt;/td>
&lt;td>attribute_length&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>number_of_exceptions&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>exception_index_table&lt;/td>
&lt;td>number_of_exceptions&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ol start="3">
&lt;li>LineNumberTable属性&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系&lt;/p>
&lt;/blockquote>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>名称&lt;/th>
&lt;th>数量&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>attribute_name_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u4&lt;/td>
&lt;td>attribute_length&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>line_number_table_length&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>line_number_info&lt;/td>
&lt;td>line_number_table&lt;/td>
&lt;td>line_number_table_length&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ol start="4">
&lt;li>LocalVariableTable及LocalVariableTypeTable属性&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系&lt;/p>
&lt;/blockquote>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>名称&lt;/th>
&lt;th>数量&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>attribute_name_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u4&lt;/td>
&lt;td>attribute_length&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>local_variable_table_length&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>local_variable_info&lt;/td>
&lt;td>local_variable_table&lt;/td>
&lt;td>local_variable_table_length&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>local_variable_info属性结构
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>名称&lt;/th>
&lt;th>数量&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>start_pc&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>length&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>name_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>descriptor_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul>
&lt;ol start="5">
&lt;li>SourceFile及SourceDebugExtension属性&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>记录生成这个Class文件的源码文件名称&lt;/p>
&lt;/blockquote>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>名称&lt;/th>
&lt;th>数量&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>attribute_name_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u4&lt;/td>
&lt;td>attribute_length&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>sourcefile_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ol start="6">
&lt;li>ConstantValue属性&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>通知虚拟机自动为静态变量赋值&lt;/p>
&lt;/blockquote>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>名称&lt;/th>
&lt;th>数量&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>attribute_name_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u4&lt;/td>
&lt;td>attribute_length&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>constantvalue_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ol start="7">
&lt;li>InnerClasses属性&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>记录内部类与宿主类之间的关联&lt;/p>
&lt;/blockquote>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>名称&lt;/th>
&lt;th>数量&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>attribute_name_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u4&lt;/td>
&lt;td>attribute_length&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>number_of_classes&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>inner_classes_info&lt;/td>
&lt;td>inner_classes&lt;/td>
&lt;td>number_of_classes&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>inner_classes_info属性结构
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>名称&lt;/th>
&lt;th>数量&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>inner_class_info_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>outer_class_info_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>inner_name_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>inner_class_access_flags&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul>
&lt;ol start="8">
&lt;li>Deprecated及Synthetic属性&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>都属于标志类型的布尔属性&lt;br>
Deprecated属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用
Synthetic属性代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的，也可以设置ACC_SYNTHETIC标志位&lt;/p>
&lt;/blockquote>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>名称&lt;/th>
&lt;th>数量&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>attribute_name_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u4&lt;/td>
&lt;td>attribute_length&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ol start="9">
&lt;li>StackMapTable属性&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>复杂的变长属性，位于Code属性的属性表中。这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器（Type Checker）使用（详见第7章字节码验证部分），目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。&lt;/p>
&lt;/blockquote>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>名称&lt;/th>
&lt;th>数量&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>attribute_name_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u4&lt;/td>
&lt;td>attribute_length&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>number_of_entries&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>stack_map_frame&lt;/td>
&lt;td>stack_map_frame_entries&lt;/td>
&lt;td>number_of_entries&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ol start="10">
&lt;li>Signature属性&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>记录泛型签名信息&lt;/p>
&lt;/blockquote>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>名称&lt;/th>
&lt;th>数量&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>attribute_name_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u4&lt;/td>
&lt;td>attribute_length&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>signature_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ol start="11">
&lt;li>BootstrapMethods属性&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>复杂的变长属性，位于类文件的属性表中。这个属性用于保存invokedynamic指令引用的引导方法限定符&lt;/p>
&lt;/blockquote>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>名称&lt;/th>
&lt;th>数量&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>attribute_name_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u4&lt;/td>
&lt;td>attribute_length&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>num_bootstrap_methods&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>bootstrap_method&lt;/td>
&lt;td>bootstrap_methods&lt;/td>
&lt;td>num_bootstrap_methods&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>bootstrap_method属性结构
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>名称&lt;/th>
&lt;th>数量&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>bootstrap_method_ref_&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>num_bootstrap_arguments&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>bootstrap_arguments&lt;/td>
&lt;td>num_bootstrap_arguments&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul>
&lt;ol start="12">
&lt;li>MethodParameters属性&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>记录方法的各个形参名称和信息&lt;/p>
&lt;/blockquote>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>名称&lt;/th>
&lt;th>数量&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>attribute_name_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u4&lt;/td>
&lt;td>attribute_length&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u1&lt;/td>
&lt;td>parameters_count&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>parameter&lt;/td>
&lt;td>parameters&lt;/td>
&lt;td>parameters_count&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>parameter属性结构
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>名称&lt;/th>
&lt;th>数量&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>name_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>access_flags&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul>
&lt;ol start="13">
&lt;li>模块化相关属性&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>Module、ModulePackages和ModuleMainClass三个属性用于支持Java模块化相关功能&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>Module:复杂的变长属性，除了表示该模块的名称、版本、标志信息以外，还存储了这个模块requires、exports、opens、uses和provides定义的全部内容&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>名称&lt;/th>
&lt;th>数量&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>attribute_name_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u4&lt;/td>
&lt;td>attribute_length&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>module_name_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>module_flags&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>module_version_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>requires_count&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>require&lt;/td>
&lt;td>requires&lt;/td>
&lt;td>requires_count&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>exports_count&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>export&lt;/td>
&lt;td>exports&lt;/td>
&lt;td>exports_count&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>opens_count&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>open&lt;/td>
&lt;td>opens&lt;/td>
&lt;td>opens_count&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>uses_count&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>use&lt;/td>
&lt;td>uses_index&lt;/td>
&lt;td>uses_count&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>provides_count&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>provide&lt;/td>
&lt;td>provides&lt;/td>
&lt;td>provides_count&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>exports属性结构&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>名称&lt;/th>
&lt;th>数量&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>exports_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>exports_flags&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>exports_to_count&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>export&lt;/td>
&lt;td>exports_to_index&lt;/td>
&lt;td>exports_to_count&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>ModulePackages:变长属性，它用于描述该模块中所有的包，不论是不是被export或者open的&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>名称&lt;/th>
&lt;th>数量&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>attribute_name_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u4&lt;/td>
&lt;td>attribute_length&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>package_count&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>package_index&lt;/td>
&lt;td>package_count&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>ModuleMainClass:定长属性，用于确定该模块的主类（Main Class）&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>名称&lt;/th>
&lt;th>数量&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>attribute_name_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u4&lt;/td>
&lt;td>attribute_length&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>main_class_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul>
&lt;ol start="14">
&lt;li>运行时注解相关属性&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>以RuntimeVisibleAnnotations为例:记录了类、字段或方法的声明上记录运行时可见注解，当我们使用反射API来获取类、字段或方法上的注解时，返回值就是通过这个属性来取到的&lt;/p>
&lt;/blockquote>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>名称&lt;/th>
&lt;th>数量&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>attribute_name_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u4&lt;/td>
&lt;td>attribute_length&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>num_annotations&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>annotation&lt;/td>
&lt;td>annotations&lt;/td>
&lt;td>num_annotations&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>annotation属性结构
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>名称&lt;/th>
&lt;th>数量&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>type_index&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u2&lt;/td>
&lt;td>num_element_value_pairs&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>element_value_pair&lt;/td>
&lt;td>element_value_pairs&lt;/td>
&lt;td>num_element_value_pairs&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul></description></item><item><title>第4章　虚拟机性能监控、故障处理工具</title><link>https://yzlc.github.io/post/read/jvm/4/</link><pubDate>Tue, 12 May 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/jvm/4/</guid><description>&lt;h2 id="42基础故障处理工具">4.2　基础故障处理工具&lt;/h2>
&lt;h3 id="421jpsjvm-process-status-tool虚拟机进程状况工具">4.2.1　jps（JVM Process Status Tool）：虚拟机进程状况工具&lt;/h3>
&lt;p>命令格式：&lt;code>jps [ options ] [ hostid ]&lt;/code>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>选项&lt;/th>
&lt;th>作用&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>-q&lt;/td>
&lt;td>只输出LVMID,省略主类的名称&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-m&lt;/td>
&lt;td>输出虚拟机进程启动时传递给主类main()函数的参数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-l&lt;/td>
&lt;td>输出主类的全名,如果进程执行的是JAR包,则输出JAR路径&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-v&lt;/td>
&lt;td>输出虚拟机进程启动时的JVM参数&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="422jstatjvm-statistics-monitoring-tool虚拟机统计信息监视工具">4.2.2　jstat（JVM Statistics Monitoring Tool）：虚拟机统计信息监视工具&lt;/h3>
&lt;p>命令格式：&lt;code>jstat [ option vmid [interval[s|ms] [count]] ]&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/jvm/4-2.jpg"
loading="lazy"
>&lt;/p>
&lt;h3 id="423jinfoconfiguration-info-for-javajava配置信息工具">4.2.3　jinfo（Configuration Info for Java）：Java配置信息工具&lt;/h3>
&lt;p>命令格式：&lt;code>jinfo [ option ] pid&lt;/code>&lt;/p>
&lt;h3 id="424jmapmemory-map-for-javajava内存映像工具">4.2.4　jmap（Memory Map for Java）：Java内存映像工具&lt;/h3>
&lt;p>命令格式：&lt;code>jmap [ option ] vmid&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/jvm/4-3.jpg"
loading="lazy"
>&lt;/p>
&lt;h3 id="425jhatjvm-heap-analysis-tool虚拟机堆转储快照分析工具">4.2.5　jhat（JVM Heap Analysis Tool）：虚拟机堆转储快照分析工具&lt;/h3>
&lt;h3 id="426jstackstack-trace-for-javajava堆栈跟踪工具">4.2.6　jstack（Stack Trace for Java）：Java堆栈跟踪工具&lt;/h3>
&lt;p>命令格式：&lt;code>jstack [ option ] vmid&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/jvm/4-4.jpg"
loading="lazy"
>&lt;/p></description></item><item><title>第3章　垃圾收集器</title><link>https://yzlc.github.io/post/read/jvm/3.5/</link><pubDate>Sat, 09 May 2020 11:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/jvm/3.5/</guid><description>&lt;h2 id="35经典垃圾收集器">3.5　经典垃圾收集器&lt;/h2>
&lt;h3 id="351serial收集器">3.5.1　Serial收集器&lt;/h3>
&lt;blockquote>
&lt;p>单线程,HotSpot虚拟机运行在客户端模式下的默认新生代收集器，对于内存资源受限的环境，它是所有收集器里额外内存消耗（Memory Footprint）最小的,微服务&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/jvm/3-7.jpg"
loading="lazy"
>&lt;/p>
&lt;h3 id="352parnew收集器">3.5.2　ParNew收集器&lt;/h3>
&lt;blockquote>
&lt;p>Serial收集器的多线程并行版本,除了Serial收集器外，目前只有它能与CMS收集器配合工作&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/jvm/3-8.jpg"
loading="lazy"
>&lt;/p>
&lt;h3 id="353parallel-scavenge收集器">3.5.3　Parallel Scavenge收集器&lt;/h3>
&lt;blockquote>
&lt;p>吞吐量优先收集器&lt;/p>
&lt;/blockquote>
&lt;p>吞吐量（Throughput）：处理器用于运行用户代码的时间/处理器总消耗时间
参数-XX：&lt;/p>
&lt;ul>
&lt;li>MaxGCPauseMillis：最大垃圾收集停顿时间,ms&lt;/li>
&lt;li>GCTimeRatio：吞吐量大小,{1/(1+x),默认x=99}&lt;/li>
&lt;li>+UseAdaptiveSizePolicy：自适应的调节策略（GC Ergonomics）&lt;/li>
&lt;/ul>
&lt;h3 id="354serial-old收集器">3.5.4　Serial Old收集器&lt;/h3>
&lt;blockquote>
&lt;p>Serial收集器的老年代版本&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/jvm/3-9.jpg"
loading="lazy"
>&lt;/p>
&lt;h3 id="355parallel-old收集器">3.5.5　Parallel Old收集器&lt;/h3>
&lt;blockquote>
&lt;p>Parallel Scavenge收集器的老年代版本&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/jvm/3-10.jpg"
loading="lazy"
>&lt;/p>
&lt;h3 id="356cms收集器concurrent-mark-sweep">3.5.6　CMS收集器（Concurrent Mark Sweep）&lt;/h3>
&lt;blockquote>
&lt;p>以获取最短回收停顿时间为目标的收集器,B/S系统&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/jvm/3-11.jpg"
loading="lazy"
>&lt;/p>
&lt;h3 id="357garbage-first收集器g1">3.5.7　Garbage First收集器(G1)&lt;/h3>
&lt;blockquote>
&lt;p>使用Region划分内存空间，以及具有优先级的区域回收方式&lt;/p>
&lt;/blockquote>
&lt;p>停顿时间模型（Pause Prediction Model）：在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒&lt;/p>
&lt;p>Mixed GC：面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大&lt;/p>
&lt;p>Region堆内存布局：把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理.Humongous区域：专门用来存储大对象
&lt;img src="https://yzlc.github.io/images/read/jvm/3-13.jpg"
loading="lazy"
>&lt;/p>
&lt;h2 id="36低延迟垃圾收集器">3.6　低延迟垃圾收集器&lt;/h2>
&lt;h3 id="361shenandoah收集器">3.6.1　Shenandoah收集器&lt;/h3>
&lt;p>并发标记（Concurrent Marking）：与G1一样，遍历对象图，标记出全部可达的对象，时间长短取决于堆中存活对象的数量以及对象图的结构复杂程度。&lt;/p>
&lt;p>并发回收（Concurrent Evacuation）：并发回收阶段是Shenandoah与之前HotSpot中其他收集器的核心差异。在这个阶段，Shenandoah要把回收集里面的存活对象先复制一份到其他未被使用的Region之中。通过读屏障和被称为“Brooks Pointers”的转发指针来解决。并发回收阶段运行的时间长短取决于回收集的大小。&lt;/p>
&lt;p>并发引用更新（Concurrent Update Reference）：真正开始进行引用更新操作，时间长短取决于内存中涉及的引用数量的多少。按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值即可。&lt;/p>
&lt;p>Brooks Pointers：在原有对象布局结构的最前面统一增加一个新的引用字段，在正常不处于并发移动的情况下，该引用指向对象自己&lt;/p>
&lt;ul>
&lt;li>每次对象访问会带来一次额外的转向开销&lt;/li>
&lt;li>并发写入：通过比较并交换（Compare And Swap，CAS）操作来保证并发时对象的访问正确性&lt;/li>
&lt;li>执行频率的问题：通过对象头上的Brooks Pointer来保证并发时原对象与复制对象的访问一致性，要覆盖全部对象访问操作，Shenandoah不得不同时设置读、写屏障去拦截。
&lt;ul>
&lt;li>引用访问屏障（Load Reference Barrier）：只拦截对象中数据类型为引用类型的读写操作，而不去管原生数据类型等其他非引用字段的读写，这能够省去大量对原生类型、对象比较、对象加锁等场景中设置内存屏障所带来的消耗&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="362zgc收集器z-garbage-collector">3.6.2　ZGC收集器(Z Garbage Collector)&lt;/h3>
&lt;blockquote>
&lt;p>基于Region内存布局，（暂时）不设分代，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法，低延迟为目标&lt;/p>
&lt;/blockquote>
&lt;p>Region：具有动态性——动态创建和销毁，以及动态的区域容量大小&lt;/p>
&lt;ul>
&lt;li>小型Region（Small Region）：容量固定为2MB，用于放置小于256KB的小对象&lt;/li>
&lt;li>中型Region（Medium Region）：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象&lt;/li>
&lt;li>大型Region（Large Region）：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。每个大型Region中只会存放一个大对象，这也预示着虽然名字叫作“大型Region”，但它的实际容量完全有可能小于中型Region，最小容量可低至4MB。大型Region在ZGC的实现中是不会被重分配的，因为复制一个大对象的代价非常高昂&lt;/li>
&lt;/ul>
&lt;p>染色指针技术（Colored Pointer）：把标记信息记在引用对象的指针上，这时，与其说可达性分析是遍历对象图来标记对象，还不如说是遍历“引用图”来标记“引用”了
&lt;img src="https://yzlc.github.io/images/read/jvm/3-20.jpg"
loading="lazy"
>&lt;/p>
&lt;p>ZGC运作过程
&lt;img src="https://yzlc.github.io/images/read/jvm/3-22.jpg"
loading="lazy"
>&lt;/p>
&lt;ul>
&lt;li>并发标记（Concurrent Mark）：标记阶段会更新染色指针中的Marked 0、Marked 1标志位&lt;/li>
&lt;li>并发预备重分配（Concurrent Prepare for Relocate）：根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）&lt;/li>
&lt;li>并发重分配（Concurrent Relocate）：重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（Forward Table），记录从旧对象到新对象的转向关系&lt;/li>
&lt;li>指针的自愈（Self-Healing）：得益于染色指针的支持，ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象
&lt;ul>
&lt;li>只有第一次访问旧对象会陷入转发，也就是只慢一次，对比Shenandoah的Brooks转发指针，那是每次对象访问都必须付出的固定开销，简单地说就是每次都慢&lt;/li>
&lt;li>由于染色指针的存在，一旦重分配集中某个Region的存活对象都复制完毕后，这个Region就可以立即释放用于新对象的分配（但是转发表还得留着不能释放掉），哪怕堆中还有很多指向这个对象的未更新指针也没有关系，这些旧指针一旦被使用，它们都是可以自愈的&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>并发重映射（Concurrent Remap）：重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，这一点从目标角度看是与Shenandoah并发引用更新阶段一样的，但是ZGC的并发重映射并不是一个必须要“迫切”去完成的任务，因为前面说过，即使是旧引用，它也是可以自愈的，最多只是第一次使用时多一次转发和修正操作。重映射清理这些旧引用的主要目的是为了不变慢（还有清理结束后可以释放转发表这样的附带收益），所以说这并不是很“迫切”。因此，ZGC很巧妙地把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成，反正它们都是要遍历所有对象的，这样合并就节省了一次遍历对象图的开销。一旦所有指针都被修正之后，原来记录新旧对象关系的转发表就可以释放掉了&lt;/li>
&lt;/ul></description></item><item><title>第3章　内存分配策略</title><link>https://yzlc.github.io/post/read/jvm/3/</link><pubDate>Sat, 09 May 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/jvm/3/</guid><description>&lt;h2 id="32对象已死">3.2　对象已死？&lt;/h2>
&lt;h3 id="321引用计数算法">3.2.1　引用计数算法&lt;/h3>
&lt;blockquote>
&lt;p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的&lt;/p>
&lt;/blockquote>
&lt;h3 id="322可达性分析算法">3.2.2　可达性分析算法&lt;/h3>
&lt;blockquote>
&lt;p>通过一系列称为GC Roots的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为引用链（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，则证明此对象是不可能再被使用的&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/jvm/3-1.jpg"
loading="lazy"
>
GC Roots&lt;/p>
&lt;ul>
&lt;li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等&lt;/li>
&lt;li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量&lt;/li>
&lt;li>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用&lt;/li>
&lt;li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象&lt;/li>
&lt;li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器&lt;/li>
&lt;li>所有被同步锁（synchronized关键字）持有的对象&lt;/li>
&lt;li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等&lt;/li>
&lt;/ul>
&lt;h3 id="323再谈引用">3.2.3　再谈引用&lt;/h3>
&lt;p>强引用（Strongly Re-ference）：普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象&lt;/p>
&lt;p>软引用（Soft Reference）：还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常&lt;/p>
&lt;p>弱引用（Weak Reference）：非必须对象，强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象&lt;/p>
&lt;p>虚引用（Phantom Reference）：最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知&lt;/p>
&lt;h3 id="324生存还是死亡">3.2.4　生存还是死亡？&lt;/h3>
&lt;blockquote>
&lt;p>可达性分析 -&amp;gt; 标记 -&amp;gt; F-Queue队列,由Finalizer线程执行finalize() -&amp;gt; 标记 -&amp;gt; 回收&lt;/p>
&lt;/blockquote>
&lt;h3 id="325回收方法区">3.2.5　回收方法区&lt;/h3>
&lt;blockquote>
&lt;p>废弃的常量和不再使用的类型，垃圾收集的性价比比较低&lt;/p>
&lt;/blockquote>
&lt;p>废弃常量：没有任何对象引用常量池中的常量，且虚拟机中也没有其他地方引用这个字面量&lt;/p>
&lt;p>不再使用的类型&lt;/p>
&lt;ul>
&lt;li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例&lt;/li>
&lt;li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的&lt;/li>
&lt;li>该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法&lt;/li>
&lt;/ul>
&lt;p>需求场景：在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力&lt;/p>
&lt;h2 id="33垃圾收集算法">3.3　垃圾收集算法&lt;/h2>
&lt;blockquote>
&lt;p>引用计数式垃圾收集（ReferenceCounting GC）和追踪式垃圾收集（Tracing GC）&lt;/p>
&lt;/blockquote>
&lt;h3 id="331分代收集理论generational-collection">3.3.1　分代收集理论（Generational Collection）&lt;/h3>
&lt;p>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的&lt;/p>
&lt;p>强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡&lt;/p>
&lt;p>跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数&lt;/p>
&lt;h3 id="332标记-清除算法mark-sweep">3.3.2　标记-清除算法（Mark-Sweep）&lt;/h3>
&lt;blockquote>
&lt;p>标记出所有需要回收的对象，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/jvm/3-2.jpg"
loading="lazy"
>
执行效率不稳定：标记和清除两个过程的执行效率随对象数量增长而降低&lt;/p>
&lt;p>内存空间碎片化：空间碎片太多导致分配较大对象时无法找到足够的连续内存而提前触发另一次垃圾收集&lt;/p>
&lt;h3 id="333标记-复制算法">3.3.3　标记-复制算法&lt;/h3>
&lt;p>半区复制（Semispace Copying）：内存按容量划分为大小相等的两块，只使用其中的一块。内存用完了就将存活的对象复制到另外一块上面，再把已使用过的内存空间一次清理掉
&lt;img src="https://yzlc.github.io/images/read/jvm/3-3.jpg"
loading="lazy"
>&lt;/p>
&lt;ul>
&lt;li>可用内存缩小为了原来的一半，空间浪费多&lt;/li>
&lt;/ul>
&lt;p>Appel式回收：把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间&lt;/p>
&lt;ul>
&lt;li>逃生门：当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）&lt;/li>
&lt;/ul>
&lt;h3 id="334标记-整理算法mark-compact">3.3.4　标记-整理算法（Mark-Compact）&lt;/h3>
&lt;blockquote>
&lt;p>让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/jvm/3-4.jpg"
loading="lazy"
>&lt;/p>
&lt;h2 id="34hotspot的算法细节实现">3.4　HotSpot的算法细节实现&lt;/h2>
&lt;h3 id="341根节点枚举">3.4.1　根节点枚举&lt;/h3>
&lt;p>枚举根节点时必须要停顿&lt;/p>
&lt;p>不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机有办法直接得到哪些地方存放着对象引用&lt;/p>
&lt;ul>
&lt;li>HotSpot使用OopMap的数据结构来达到这个目的&lt;/li>
&lt;/ul>
&lt;h3 id="342安全点safepoint">3.4.2　安全点（Safepoint）&lt;/h3>
&lt;blockquote>
&lt;p>为了解决引用关系变化的问题，只在“特定的位置”记录OopMap信息&lt;/p>
&lt;/blockquote>
&lt;p>选取标准：是否具有让程序长时间执行的特征,“长时间执行”的最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转等&lt;/p>
&lt;p>方案1：抢先式中断（Preemptive Suspension）：把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上&lt;/p>
&lt;p>方案2：主动式中断（Voluntary Suspension）：设置一个标志位，各个线程轮询，中断标志为真时在最近的安全点上挂起。轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象&lt;/p>
&lt;ul>
&lt;li>HotSpot使用内存保护陷阱的方式，当需要暂停用户线程时，虚拟机把内存页设置为不可读，那线程执行到test指令时就会产生一个自陷异常信号，然后在预先注册的异常处理器中挂起线程实现等待&lt;/li>
&lt;/ul>
&lt;h3 id="343安全区域">3.4.3　安全区域&lt;/h3>
&lt;blockquote>
&lt;p>指能够确保在某一段代码片段之中，引用关系不会发生变化，在这个区域中任意地方开始垃圾收集都是安全的&lt;/p>
&lt;/blockquote>
&lt;p>场景：程序“不执行”的时候(Sleep、Blocked)&lt;/p>
&lt;p>执行安全区域的代码时，首先标识进入了安全区域，虚拟机垃圾收集时不必去管安全区域的线程。离开安全区域时，如果虚拟机没有完成根节点枚举，就必须等待可以离开安全区域的信号&lt;/p>
&lt;h3 id="344记忆集remembered-set与卡表card-table">3.4.4　记忆集（Remembered Set）与卡表（Card Table）&lt;/h3>
&lt;blockquote>
&lt;p>为解决对象跨代引用所带来的问题，避免把整个老年代加进GC Roots扫描范围&lt;br>
记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构&lt;br>
卡表是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等&lt;/p>
&lt;/blockquote>
&lt;p>记忆集&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Class&lt;/span> &lt;span class="n">RememberedSet&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Object&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="n">set&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">OBJECT_INTERGENERATIONAL_REFERENCE_SIZE&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>记录精度
&lt;ul>
&lt;li>字长精度：每个记录精确到一个机器字长，该字包含跨代指针&lt;/li>
&lt;li>对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针&lt;/li>
&lt;li>卡精度(卡表)：每个记录精确到一块内存区域，该区域内有对象含有跨代指针&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>卡表&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">CARD_TABLE&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">this&lt;/span> &lt;span class="n">address&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="mi">9&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>卡页（Card Page）：字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/jvm/3-5.jpg"
loading="lazy"
>&lt;/p>
&lt;ul>
&lt;li>一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，称为这个元素变脏（Dirty），没有则标识为0。在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描&lt;/li>
&lt;/ul>
&lt;h3 id="345写屏障write-barrier">3.4.5　写屏障（Write Barrier）&lt;/h3>
&lt;blockquote>
&lt;p>写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面，在引用对象赋值时会产生一个环形（Around）通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。在赋值前的部分的写屏障叫作写前屏障（Pre-Write Barrier），在赋值后的则叫作写后屏障（Post-Write Barrier）&lt;/p>
&lt;/blockquote>
&lt;p>伪共享（False Sharing）：现代中央处理器的缓存系统中是以缓存行（Cache Line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低&lt;/p>
&lt;ul>
&lt;li>解决方案(-XX：+UseCondCardMark)：检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">CARD_TABLE&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">this&lt;/span> &lt;span class="n">address&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="mi">9&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">CARD_TABLE&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">this&lt;/span> &lt;span class="n">address&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="mi">9&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="346并发的可达性分析">3.4.6　并发的可达性分析&lt;/h3>
&lt;p>三色标记（Tri-color Marking）&lt;/p>
&lt;ul>
&lt;li>白色：表示对象尚未被垃圾收集器访问过。开始的阶段都是白色，结束的阶段代表不可达&lt;/li>
&lt;li>黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象&lt;/li>
&lt;li>灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/jvm/%e8%a1%a83-1.jpg"
loading="lazy"
>&lt;/p>
&lt;p>对象消失,当以下两个条件同时满足时&lt;/p>
&lt;ol>
&lt;li>赋值器插入了一条或多条从黑色对象到白色对象的新引用&lt;/li>
&lt;li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>解决方案(通过写屏障实现)
&lt;ul>
&lt;li>增量更新（Incremental Update）,破坏条件1：当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了&lt;/li>
&lt;li>原始快照（Snapshot At The Beginning，SATB）,破坏条件2：当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>第2章　Java内存区域与内存溢出异常</title><link>https://yzlc.github.io/post/read/jvm/2/</link><pubDate>Fri, 08 May 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/jvm/2/</guid><description>&lt;h2 id="22运行时数据区域">2.2　运行时数据区域&lt;/h2>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/jvm/2-1.jpg"
loading="lazy"
>&lt;/p>
&lt;h3 id="221程序计数器program-counter-register">2.2.1　程序计数器（Program Counter Register）&lt;/h3>
&lt;blockquote>
&lt;p>字节码的行号指示器，程序控制流的指示器（分支、循环、跳转、异常处理、线程恢复等）&lt;/p>
&lt;/blockquote>
&lt;p>记录内容&lt;/p>
&lt;ul>
&lt;li>执行Java方法：记录虚拟机字节码指令地址&lt;/li>
&lt;li>执行本地（Native）方法：值为空（Undefined）&lt;/li>
&lt;/ul>
&lt;p>异常情况&lt;/p>
&lt;ul>
&lt;li>唯一一个没有规定OutOfMemoryError的区域&lt;/li>
&lt;/ul>
&lt;h3 id="222java虚拟机栈java-virtual-machine-stack">2.2.2　Java虚拟机栈（Java Virtual Machine Stack）&lt;/h3>
&lt;blockquote>
&lt;p>Java方法执行的线程内存模型：方法被执行的时候，同步创建一个栈帧（Stack Frame）（存储局部变量表、操作数栈、动态连接、方法出口等信息）。方法执行过程对应栈帧从入栈到出栈的过程&lt;/p>
&lt;/blockquote>
&lt;p>异常情况&lt;/p>
&lt;ul>
&lt;li>StackOverflow：线程请求的栈深度 &amp;gt; 虚拟机允许的深度&lt;/li>
&lt;li>OutOfMemory：栈扩展无法申请到足够的内存时&lt;/li>
&lt;/ul>
&lt;p>局部变量表&lt;/p>
&lt;blockquote>
&lt;p>存放基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型）和returnAddress类型（指向一条字节码指令的地址）&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>存储空间
&lt;ul>
&lt;li>局部变量槽（Slot）：64位的long和double占用两个变量槽，其余的数据类型只占用一个&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>内存分配
&lt;ul>
&lt;li>在编译期完成分配：进入方法时，需要在栈帧中分配的局部变量空间是确定的，方法运行期间不会改变局部变量表的大小(变量槽的数量)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="223本地方法栈native-method-stacks">2.2.3　本地方法栈（Native Method Stacks）&lt;/h3>
&lt;blockquote>
&lt;p>为虚拟机使用到的本地（Native）方法服务&lt;/p>
&lt;/blockquote>
&lt;h3 id="224java堆java-heap">2.2.4　Java堆（Java Heap）&lt;/h3>
&lt;blockquote>
&lt;p>在虚拟机启动时创建，几乎所有的对象实例都在这里分配内存。垃圾收集器管理的内存区域（GC堆（Garbage Collected Heap））&lt;/p>
&lt;/blockquote>
&lt;p>异常情况&lt;/p>
&lt;ul>
&lt;li>OutOfMemory：没有内存完成实例分配，并且堆也无法再扩展&lt;/li>
&lt;/ul>
&lt;h3 id="225方法区method-area">2.2.5　方法区（Method Area）&lt;/h3>
&lt;blockquote>
&lt;p>存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据&lt;/p>
&lt;/blockquote>
&lt;p>异常情况&lt;/p>
&lt;ul>
&lt;li>OutOfMemory：方法区无法满足新的内存分配需求&lt;/li>
&lt;/ul>
&lt;h3 id="226运行时常量池runtime-constant-pool">2.2.6　运行时常量池（Runtime Constant Pool）&lt;/h3>
&lt;blockquote>
&lt;p>方法区的一部分。Class文件中的常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，类加载后存放到运行时常量池中&lt;/p>
&lt;/blockquote>
&lt;p>对比Class文件常量池&lt;/p>
&lt;ul>
&lt;li>Class文件的格式有严格规定，运行时常量池没有做任何细节的要求（一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中）&lt;/li>
&lt;li>运行时常量池具备动态性，运行期间可以将新的常量放入池中，例如String类的intern()方法&lt;/li>
&lt;/ul>
&lt;p>异常情况&lt;/p>
&lt;ul>
&lt;li>OutOfMemory：常量池无法再申请到内存&lt;/li>
&lt;/ul>
&lt;h3 id="227直接内存direct-memory">2.2.7　直接内存（Direct Memory）&lt;/h3>
&lt;blockquote>
&lt;p>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。使用Native函数库直接分配堆外内存，通过存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作&lt;/p>
&lt;/blockquote>
&lt;p>特点&lt;/p>
&lt;ul>
&lt;li>能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据&lt;/li>
&lt;/ul>
&lt;p>异常情况&lt;/p>
&lt;ul>
&lt;li>OutOfMemory：忽略直接内存，使得各个内存区域总和大于物理内存限制，导致动态扩展&lt;/li>
&lt;/ul>
&lt;h2 id="23hotspot虚拟机对象探秘">2.3　HotSpot虚拟机对象探秘&lt;/h2>
&lt;h3 id="231对象的创建">2.3.1　对象的创建&lt;/h3>
&lt;blockquote>
&lt;p>new -&amp;gt; 检查常量池中类是否已被加载 -&amp;gt; 分配内存 -&amp;gt; 初始化零值 -&amp;gt; 设置对象头 -&amp;gt; 执行构造函数&lt;/p>
&lt;/blockquote>
&lt;p>内存分配方式(由堆是否规整决定)&lt;/p>
&lt;ul>
&lt;li>指针碰撞（Bump The Pointer）：内存规整，使用的放一边，空闲的放一边，中间放指针作为分界点的指示器，分配内存就是把那个指针向空闲空间方向挪动与对象大小相等的距离&lt;/li>
&lt;li>空闲列表（Free List）：内存不规整，维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录&lt;/li>
&lt;/ul>
&lt;p>堆是否规整&lt;/p>
&lt;ul>
&lt;li>使用Serial、ParNew等带压缩整理（Compact）&lt;/li>
&lt;li>使用CMS基于清除（Sweep）算法的收集器&lt;/li>
&lt;/ul>
&lt;p>线程安全&lt;/p>
&lt;ul>
&lt;li>同步处理：CAS配上失败重试的方式保证更新操作的原子性&lt;/li>
&lt;li>按线程划分在不同的空间之中进行：TLAB，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定
&lt;ul>
&lt;li>本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）：每个线程在Java堆中预先分配一小块内存&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>对象头（Object Header）：对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（真正调hashCode()时计算）、对象的GC分代年龄等&lt;/p>
&lt;h3 id="232对象的内存布局">2.3.2　对象的内存布局&lt;/h3>
&lt;blockquote>
&lt;p>对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）&lt;/p>
&lt;/blockquote>
&lt;p>对象头&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Mark Word：存储对象自身的运行时数据，有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间，长度为32个比特(32位)和64个比特(64位)&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>存储内容&lt;/th>
&lt;th>标志&lt;/th>
&lt;th>状态&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>对象哈希码、对象分代年龄&lt;/td>
&lt;td>01&lt;/td>
&lt;td>未锁定&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>指向锁记录的指针&lt;/td>
&lt;td>00&lt;/td>
&lt;td>轻量级锁定&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>指向重量级锁的指针&lt;/td>
&lt;td>10&lt;/td>
&lt;td>膨胀(重量级锁定)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>空,不需要记录信息&lt;/td>
&lt;td>11&lt;/td>
&lt;td>GC标记&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>偏向线程ID、偏向时间戳、对象分代年龄&lt;/td>
&lt;td>01&lt;/td>
&lt;td>可偏向&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>类型指针：对象指向它的类型元数据的指针，通过指针来确定对象是哪个类的实例&lt;/p>
&lt;ul>
&lt;li>不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身&lt;/li>
&lt;li>数组在对象头中必须有一块用于记录数组长度的数据：元数据信息可以确定Java对象的大小，但如果数组的长度是不确定的，无法通过元数据中的信息推断出数组的大小&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>实例数据：对象真正存储的有效信息，代码中各种类型的字段内容，无论父类继承还是子类定义的字段都记录起来&lt;/p>
&lt;p>对齐填充：占位符的作用。HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍&lt;/p>
&lt;h3 id="233对象的访问定位">2.3.3　对象的访问定位&lt;/h3>
&lt;blockquote>
&lt;p>通过栈上的reference数据来操作堆上的具体对象，主流的访问方式有句柄和直接指针两种&lt;/p>
&lt;/blockquote>
&lt;p>句柄：划分出一块内存来作为句柄池，reference中存储的对象的句柄地址，句柄中包含对象实例数据与类型数据各自具体的地址信息
&lt;img src="https://yzlc.github.io/images/read/jvm/2-2.jpg"
loading="lazy"
>&lt;/p>
&lt;ul>
&lt;li>好处： reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改&lt;/li>
&lt;/ul>
&lt;p>直接指针：必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，只访问对象本身的话，就不需要多一次间接访问的开销
&lt;img src="https://yzlc.github.io/images/read/jvm/2-3.jpg"
loading="lazy"
>&lt;/p>
&lt;ul>
&lt;li>好处： 速度更快，节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本&lt;/li>
&lt;/ul></description></item><item><title>第1章　走近Java</title><link>https://yzlc.github.io/post/read/jvm/1/</link><pubDate>Thu, 30 Apr 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/jvm/1/</guid><description>&lt;h2 id="16-实战自己编译jdk">1.6 实战:自己编译JDK&lt;/h2>
&lt;h3 id="161-获取源码">1.6.1 获取源码&lt;/h3>
&lt;p>&lt;a class="link" href="https://hg.openjdk.java.net/jdk/jdk12/" target="_blank" rel="noopener"
>下载&lt;/a> -&amp;gt; browse -&amp;gt; zip&lt;/p>
&lt;h3 id="163-构建编译环境ubuntu">1.6.3 构建编译环境(Ubuntu)&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>工具&lt;/th>
&lt;th>命令&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GCC&lt;/td>
&lt;td>&lt;code>sudo apt-get install build-essential&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>FreeType&lt;/td>
&lt;td>&lt;code>sudo apt-get install libfreetype6-dev&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CUPS&lt;/td>
&lt;td>&lt;code>sudo apt-get install libcups2-dev&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>X11&lt;/td>
&lt;td>&lt;code>sudo apt-get install libx11-dev libxext-dev libxrender-dev libxrandr-dev libxtst-dev libxt-dev&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ALSA&lt;/td>
&lt;td>&lt;code>sudo apt-get install libasound2-dev&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>libffi&lt;/td>
&lt;td>&lt;code>sudo apt-get install libffi-dev&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Autoconf&lt;/td>
&lt;td>&lt;code>sudo apt-get install autoconf&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>openjdk-11&lt;/td>
&lt;td>&lt;code>sudo apt-get install openjdk-11-jdk&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>zip&lt;/td>
&lt;td>&lt;code>sudo apt-get install zip&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>libfontconfig&lt;/td>
&lt;td>&lt;code>sudo apt-get install libfontconfig1-dev&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>切换gcc&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#安装&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt-get install gcc-7
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#配置&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 &lt;span class="m">100&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo update-alternatives --config gcc
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#查看版本&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">gcc -v
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>切换g++&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#安装&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt-get install g++-7
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#配置&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-7 &lt;span class="m">100&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo update-alternatives --config g++
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#查看版本&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">g++ -v
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="164-进行编译">1.6.4 进行编译&lt;/h3>
&lt;p>常用配置(&lt;code>bash configure --help&lt;/code>)&lt;/p>
&lt;ul>
&lt;li>&lt;code>--with-debug-level=&amp;lt;level&amp;gt;&lt;/code>:编译级别(release, fastdebug, slowdebug),越往后优化少调试信息多&lt;/li>
&lt;li>&lt;code>--enable-debug&lt;/code>:等效于&lt;code>--with-debug-level=fastdebug&lt;/code>&lt;/li>
&lt;li>&lt;code>--with-native-debug-symbols=&amp;lt;method&amp;gt;&lt;/code>:确定调试符号信息的编译方式(none, internal, external, zipped)&lt;/li>
&lt;li>&lt;code>--with-version-string=&amp;lt;string&amp;gt;&lt;/code>:设置编译jdk版本号&lt;/li>
&lt;/ul>
&lt;p>编译配置&lt;code>bash configure --enable-debug --with-jvm-variants=server&lt;/code>&lt;/p>
&lt;p>编译&lt;code>make images&lt;/code>&lt;/p>
&lt;p>检查&lt;code>build/配置名称/jdk/bin/java -version&lt;/code>&lt;/p></description></item></channel></rss>