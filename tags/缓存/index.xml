<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>缓存 on YZLC</title><link>https://yzlc.github.io/tags/%E7%BC%93%E5%AD%98/</link><description>Recent content in 缓存 on YZLC</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 23 Apr 2021 15:08:33 +0800</lastBuildDate><atom:link href="https://yzlc.github.io/tags/%E7%BC%93%E5%AD%98/index.xml" rel="self" type="application/rss+xml"/><item><title>redis</title><link>https://yzlc.github.io/post/note/dev/java/redis/</link><pubDate>Fri, 23 Apr 2021 15:08:33 +0800</pubDate><guid>https://yzlc.github.io/post/note/dev/java/redis/</guid><description>&lt;blockquote>
&lt;p>内存数据库。丰富的数据类型、灾难恢复、集群、过期策略&lt;/p>
&lt;/blockquote>
&lt;h2 id="数据结构">数据结构&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>命令&lt;/th>
&lt;th>场景&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>string&lt;/td>
&lt;td>set,get,strlen,exists,decr,incr,setex&lt;/td>
&lt;td>计数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>list&lt;/td>
&lt;td>rpush,lpop,lpush,rpop,lrange、llen&lt;/td>
&lt;td>发布订阅、消息队列、慢查询&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>hash&lt;/td>
&lt;td>hset,hmset,hexists,hget,hgetall,hkeys,hvals&lt;/td>
&lt;td>系统中对象数据的存储&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>set&lt;/td>
&lt;td>sadd,spop,smembers,sismember,scard,sinterstore,sunion&lt;/td>
&lt;td>不重复以及获取交集和并集&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>sorted set&lt;/td>
&lt;td>zadd,zcard,zscore,zrange,zrevrange,zrem&lt;/td>
&lt;td>根据某个权重排序。比如直播排行、用户列表、礼物排行、弹幕&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>bitmap&lt;/td>
&lt;td>setbit 、getbit 、bitcount、bitop&lt;/td>
&lt;td>状态信息（是否签到）并进一步分析。比如用户行为（是否点赞某个视频）&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>缓存</title><link>https://yzlc.github.io/post/note/dev/java/cache/</link><pubDate>Tue, 20 Apr 2021 09:03:33 +0800</pubDate><guid>https://yzlc.github.io/post/note/dev/java/cache/</guid><description>&lt;h2 id="特征">特征&lt;/h2>
&lt;blockquote>
&lt;p>命中率、最大空间、清空策略&lt;/p>
&lt;/blockquote>
&lt;h3 id="过期数据删除策略">过期数据删除策略&lt;/h3>
&lt;ul>
&lt;li>惰性删除：只会在取出 key 的时候才对数据进行过期检查。对 CPU 友好，但是可能会造成太多过期 key 没有被删除&lt;/li>
&lt;li>定期删除：每隔一段时间抽取一批 key 执行删除过期 key 操作。通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。&lt;/li>
&lt;/ul>
&lt;h3 id="清空策略">清空策略&lt;/h3>
&lt;ul>
&lt;li>FIFO(first in first out)：先进先出。算法比较创建时间。数据实效性场景&lt;/li>
&lt;li>LFU(less frequently used)：使用次数。算法比较命中次数。高频数据场景&lt;/li>
&lt;li>LRU(least recently used)：最近最少使用。算法比较最近被get时间。热点数据场景&lt;/li>
&lt;/ul>
&lt;h2 id="本地缓存">本地缓存&lt;/h2>
&lt;blockquote>
&lt;p>在应用中的缓存组件，不适用于共享缓存。Guava Cache&lt;/p>
&lt;/blockquote>
&lt;h2 id="分布式缓存">分布式缓存&lt;/h2>
&lt;blockquote>
&lt;p>与应用分离的缓存。&lt;a class="link" href="https://yzlc.github.io/post/note/dev/redis" >redis&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="读写策略">读写策略&lt;/h2>
&lt;h3 id="cache-aside旁路缓存">Cache Aside(旁路缓存)&lt;/h3>
&lt;blockquote>
&lt;p>以DB数据为准，按需加载到cache&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>读：有cache ? 返回 : 读DB后更新cache&lt;/li>
&lt;li>写：更新DB后删除cache&lt;/li>
&lt;/ul>
&lt;h3 id="readwrite-through读写穿透">Read/Write Through(读写穿透)&lt;/h3>
&lt;blockquote>
&lt;p>把cache视为主要数据存储，缓存和DB通信&lt;/p>
&lt;/blockquote>
&lt;h3 id="write-back写回">Write Back(写回)&lt;/h3>
&lt;blockquote>
&lt;p>异步更新DB&lt;/p>
&lt;/blockquote>
&lt;h2 id="问题">问题&lt;/h2>
&lt;h3 id="缓存穿透">缓存穿透&lt;/h3>
&lt;blockquote>
&lt;p>读服务大量请求一些不可能存在在缓存里的数据&lt;/p>
&lt;/blockquote>
&lt;p>参数校验，布隆过滤器&lt;/p>
&lt;h3 id="缓存雪崩">缓存雪崩&lt;/h3>
&lt;blockquote>
&lt;p>在某个时间，有大量缓存键过期&lt;/p>
&lt;/blockquote>
&lt;p>错开过期时间&lt;/p>
&lt;h3 id="缓存击穿">缓存击穿&lt;/h3>
&lt;blockquote>
&lt;p>由于一个或少量几个热键过期导致&lt;/p>
&lt;/blockquote>
&lt;p>热键特殊处理，热键不过期&lt;/p></description></item></channel></rss>