<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>算法 on lim</title><link>https://yzlc.github.io/tags/%E7%AE%97%E6%B3%95/</link><description>Recent content in 算法 on lim</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 10 Sep 2020 10:52:33 +0800</lastBuildDate><atom:link href="https://yzlc.github.io/tags/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml"/><item><title>leetcode初级算法</title><link>https://yzlc.github.io/post/note/dev/leetcode/easy/</link><pubDate>Thu, 10 Sep 2020 10:52:33 +0800</pubDate><guid>https://yzlc.github.io/post/note/dev/leetcode/easy/</guid><description>数组 旋转图像 将矩阵划分为4部分旋转 ij 交换轨迹 00 00-&amp;gt;30-&amp;gt;33-&amp;gt;03 01 01-&amp;gt;20-&amp;gt;32-&amp;gt;13 10 10-&amp;gt;31-&amp;gt;23-&amp;gt;02 11 11-&amp;gt;21-&amp;gt;22-&amp;gt;12 坐标 (i,j)-&amp;gt;(len-1-j,i)-&amp;gt;(len-1-i,len-1-j)-&amp;gt;(j,len-1-i) 1 2 3 4 5 6 7 8 9 10 11 12 public void rotate(int[][] matrix){ int len = matrix.length; for (int i = 0; i &amp;lt; (len + 1) / 2; i++) { for (int j</description></item><item><title>5.2　单词查找树</title><link>https://yzlc.github.io/post/read/algorithms/5.2/</link><pubDate>Tue, 01 Sep 2020 13:41:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/algorithms/5.2/</guid><description>public class StringST StringST() 创建一个符号表 void put(String key, Value val) 向表中插入键值对（如果值为 null 则删除键key ） Value get(String key) 键 key 所对应的值（如果键不存在则返回 null） void delete(String key) 删除键 key</description></item><item><title>第 5 章　字符串</title><link>https://yzlc.github.io/post/read/algorithms/5/</link><pubDate>Tue, 01 Sep 2020 09:11:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/algorithms/5/</guid><description>5.1 字符串排序 5.1.1 键索引计数法 5.1.1.1 频率统计 5.1.1.2 将频率转换为索引 5.1.1.3 数据分类 5.1.1.4 回写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int N = a.length; String[] aux = new String[N]; int[] count = new int[R+1]; // 计算出现频</description></item><item><title>4.4　最短路径</title><link>https://yzlc.github.io/post/read/algorithms/4.4/</link><pubDate>Tue, 11 Aug 2020 15:53:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/algorithms/4.4/</guid><description>应用 顶点 边 地图 交叉路口 公路 网络 路由器 网络连接 任务调度 任务 优先级限制 套汇 货币 汇率 4.4.2 加权有向图的数据结构 public class DirectedEdge DirectedEdge(int v, int w, double weight) double weight() 边的权重 int from() 指出这</description></item><item><title>4.3　最小生成树</title><link>https://yzlc.github.io/post/read/algorithms/4.3/</link><pubDate>Tue, 11 Aug 2020 14:46:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/algorithms/4.3/</guid><description>权值（树中所有边的权值之和）最小的生成树 加权图：为每条边关联一个权值或是成本的图模型 图的生成树：含有其所有顶点的无环连通子图 4.3.1 原理 4.3.1.1 切分定理</description></item><item><title>4.2　有向图</title><link>https://yzlc.github.io/post/read/algorithms/4.2/</link><pubDate>Mon, 10 Aug 2020 13:24:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/algorithms/4.2/</guid><description>4.2.1 术语 由一组顶点和一组有方向的边组成的，每条有方向的边都连接着有序的一对顶点 4.2.2 有向图的数据类型 public class Digraph Digraph(int V) 创建一幅含有V个顶点但没有边的有向图</description></item><item><title>第4章　图</title><link>https://yzlc.github.io/post/read/algorithms/4.1/</link><pubDate>Fri, 07 Aug 2020 09:58:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/algorithms/4.1/</guid><description>4.1 无向图 图是由一组顶点和一组能够将两个顶点相连的边组成的 4.1.2 表示无向图的数据类型 public class Graph Graph(int V) 创建一个含有V个顶点但不含有边的图 Graph(In in) 从标准输入流 in</description></item><item><title>3.4 散列表</title><link>https://yzlc.github.io/post/read/algorithms/3.4/</link><pubDate>Wed, 05 Aug 2020 10:28:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/algorithms/3.4/</guid><description>用散列函数将被查找的键转化为数组的一个索引 处理碰撞冲突：拉链法和线性探测法 3.4.1 散列函数 3.4.1.2 正整数 除留余数法(k%M，M是素数) 3.4.1.3 浮点数 将键表示为</description></item><item><title>3.3　平衡查找树</title><link>https://yzlc.github.io/post/read/algorithms/3.3/</link><pubDate>Wed, 15 Jul 2020 15:28:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/algorithms/3.3/</guid><description>3.3.1 2-3 查找树 2-结点，含有一个键（及其对应的值）和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。 3-</description></item><item><title>3.2　二叉查找树</title><link>https://yzlc.github.io/post/read/algorithms/3.2/</link><pubDate>Wed, 15 Jul 2020 14:28:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/algorithms/3.2/</guid><description>一棵二叉查找树 （BST）是一棵二叉树，其中每个结点都含有一个Comparable 的键（以及相关联的值）且每个结点的键都大于其左子树中 的任意结</description></item><item><title>第3章　查找</title><link>https://yzlc.github.io/post/read/algorithms/3.1/</link><pubDate>Wed, 15 Jul 2020 13:28:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/algorithms/3.1/</guid><description>3.1 符号表 符号表是一种存储键值对的数据结构，支持两种操作：插入（put），即将一组新的键值对存入表中；查找 （get），即根据给定的键得到相应的</description></item><item><title>第2章　排序</title><link>https://yzlc.github.io/post/read/algorithms/2/</link><pubDate>Tue, 07 Jul 2020 10:27:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/algorithms/2/</guid><description>2.1 初级排序算法 2.1.2 选择排序 不断地选择剩余元素之中的最小者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Selection { public static boolean less(Comparable v, Comparable w) { return v.compareTo(w) &amp;lt; 0; } private static void exch(Comparable[] a, int i, int j) { Comparable</description></item><item><title>第1章　基础</title><link>https://yzlc.github.io/post/read/algorithms/1/</link><pubDate>Thu, 02 Jul 2020 14:01:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/algorithms/1/</guid><description>1.3 背包、队列和栈 1.3.1 API 1.3.1.4 背包 不支持从中删除元素的集合数据类型——它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素 1.3.1.5 先进先出队列 先进先出队</description></item></channel></rss>