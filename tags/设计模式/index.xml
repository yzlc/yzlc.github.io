<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>设计模式 on YZLC</title><link>https://yzlc.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><description>Recent content in 设计模式 on YZLC</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 15 Jul 2019 13:32:28 +0800</lastBuildDate><atom:link href="https://yzlc.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>行为型模式</title><link>https://yzlc.github.io/post/read/designpattern/behavioral/</link><pubDate>Mon, 15 Jul 2019 13:32:28 +0800</pubDate><guid>https://yzlc.github.io/post/read/designpattern/behavioral/</guid><description>&lt;h2 id="策略模式strategy">策略模式（Strategy）&lt;/h2>
&lt;blockquote>
&lt;p>定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/designPattern/behavioral/strategy.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="优点">优点&lt;/h3>
&lt;ul>
&lt;li>以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合&lt;/li>
&lt;li>Strategy类层次为Context定义了一系列可重用的算法或行为。继承有助于析取出这些算法中的公共功能&lt;/li>
&lt;li>简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试&lt;/li>
&lt;li>不同的行为堆砌在一个类中时，很难避免使用条件语句来选择合适的行为。将这些行为封装在一个个独立的Strategy类中，可以在使用这些行为的类中消除条件语句&lt;/li>
&lt;/ul>
&lt;h3 id="应用">应用&lt;/h3>
&lt;ul>
&lt;li>需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性&lt;/li>
&lt;li>选择所用具体实现的职责由客户端对象承担，并转给策略模式的Context对象&lt;/li>
&lt;/ul>
&lt;h2 id="模板方法模式template-method">模板方法模式（Template Method）&lt;/h2>
&lt;blockquote>
&lt;p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/designPattern/behavioral/templateMethod.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="优点-1">优点&lt;/h3>
&lt;ul>
&lt;li>把不变行为搬移到超类，去除子类中的重复代码&lt;/li>
&lt;/ul>
&lt;h2 id="观察者模式observer">观察者模式（Observer）&lt;/h2>
&lt;blockquote>
&lt;p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/designPattern/behavioral/observer.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="缺点">缺点&lt;/h3>
&lt;ul>
&lt;li>抽象通知者还是依赖抽象观察者&lt;/li>
&lt;li>通知方法被固定&lt;/li>
&lt;/ul>
&lt;h3 id="事件委托">事件委托&lt;/h3>
&lt;blockquote>
&lt;p>委托就是一种引用方法的类型。一旦为委托分配了方法，委托将与该方法具有完全相同的行为。委托方法的使用可以像其他任何方法一样，具有参数和返回值。委托可以看作是对函数的抽象，是函数的’类‘，委托的实例将代表一个具体的函数&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/designPattern/behavioral/delegate.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="状态模式state">状态模式（State）&lt;/h2>
&lt;blockquote>
&lt;p>当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/designPattern/behavioral/state.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="优点-2">优点&lt;/h3>
&lt;ul>
&lt;li>将与特定状态相关的行为局部化，并且将不同状态的行为分割开来&lt;/li>
&lt;li>将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在于某个ConcreteState中，所以通过定义新的子类可以很容易地增加新的状态和转换，消除庞大的条件分支语句&lt;/li>
&lt;li>状态模式通过把各种状态转移逻辑分布到State的子类之间，来减少相互间的依赖&lt;/li>
&lt;/ul>
&lt;h3 id="应用-1">应用&lt;/h3>
&lt;ul>
&lt;li>当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为&lt;/li>
&lt;/ul>
&lt;h2 id="备忘录模式memento">备忘录模式（Memento）&lt;/h2>
&lt;blockquote>
&lt;p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/designPattern/behavioral/memento.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="应用-2">应用&lt;/h3>
&lt;ul>
&lt;li>适用于功能比较复杂的，但需要维护或记录属性历史的类&lt;/li>
&lt;/ul>
&lt;h2 id="命令模式command">命令模式（Command）&lt;/h2>
&lt;blockquote>
&lt;p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/designPattern/behavioral/command.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="优点-3">优点&lt;/h3>
&lt;ul>
&lt;li>把请求一个操作的对象与知道怎么执行一个操作的对象分割开&lt;/li>
&lt;li>容易地设计一个命令队列&lt;/li>
&lt;li>容易地将命令记入日志&lt;/li>
&lt;li>允许接受请求的一方决定是否要否决请求&lt;/li>
&lt;li>容易地实现对请求的撤销和重做&lt;/li>
&lt;li>增加新的具体命令类很容易&lt;/li>
&lt;/ul>
&lt;h3 id="应用-3">应用&lt;/h3>
&lt;ul>
&lt;li>敏捷开发原则告诉我们，不要为代码添加基于猜测的，实际不需要的功能。如果不清楚一个系统是否需要命令模式，一般就不要着急去实现它，事实上，在需要的时候通过重构实现这个模式并不困难，只有在真正需要如撤销/恢复操作等功能时，把原来的代码重构为命令模式才有意义&lt;/li>
&lt;/ul>
&lt;h2 id="迭代器模式iterator">迭代器模式（Iterator）&lt;/h2>
&lt;blockquote>
&lt;p>提供一种方法顺序访问一个聚合对象中各个元素，而又不是暴露该对象的内部表示&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/designPattern/behavioral/iterator.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="职责链模式chain-of-responsibility">职责链模式（Chain of Responsibility）&lt;/h2>
&lt;blockquote>
&lt;p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/designPattern/behavioral/chainofResponsibility.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="优点-4">优点&lt;/h3>
&lt;ul>
&lt;li>可简化对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用&lt;/li>
&lt;li>可随时地增加或修改处理一个请求的结构。增强了给对象指派职责的灵活性&lt;/li>
&lt;/ul>
&lt;h2 id="中介者模式mediator">中介者模式（Mediator）&lt;/h2>
&lt;blockquote>
&lt;p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/designPattern/behavioral/mediator.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="优点-5">优点&lt;/h3>
&lt;ul>
&lt;li>减少了各个Colleague的耦合，使得可以独立地改变和复用各个Colleague类和Mediator&lt;/li>
&lt;li>由于把对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，这样关注的对象就从对象各自本身的行为转移到它们之间的交互上来，也就是站在一个更宏观的角度去看待系统&lt;/li>
&lt;/ul>
&lt;h3 id="缺点-1">缺点&lt;/h3>
&lt;ul>
&lt;li>由于ConcreteMediator控制了集中化，于是就把交互复杂性变为了中介者的复杂性，这就使得中介者会变得比任何一个ConcreteColleague都复杂&lt;/li>
&lt;/ul>
&lt;h3 id="应用-4">应用&lt;/h3>
&lt;ul>
&lt;li>用于一组对象以定义良好但是复杂的方式进行通信的场合&lt;/li>
&lt;li>想定制一个分布在多个类中的行为，而又不想生成太多的子类&lt;/li>
&lt;/ul>
&lt;h2 id="解释器模式interpreter">解释器模式（Interpreter）&lt;/h2>
&lt;blockquote>
&lt;p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/designPattern/behavioral/interpreter.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="应用-5">应用&lt;/h3>
&lt;ul>
&lt;li>当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树时&lt;/li>
&lt;/ul>
&lt;h3 id="优点-6">优点&lt;/h3>
&lt;ul>
&lt;li>容易地改变和扩展文化，因为该模式使用类来表示文化规则，可使用继承来改变或扩展该文化。也比较容易实现文化，因为定义抽象语法树中各个节点的类的实现大体类似，这些类都易于直接编写&lt;/li>
&lt;/ul>
&lt;h3 id="缺点-2">缺点&lt;/h3>
&lt;ul>
&lt;li>为文法中的每一条规则至少定义了一个类，因此包含许多规则的方法可能难以管理和维护。建议当文化非常复杂时，使用其他的技术如语法分析程序或编译器生成器来处理&lt;/li>
&lt;/ul>
&lt;h2 id="访问者模式visitor">访问者模式（Visitor）&lt;/h2>
&lt;blockquote>
&lt;p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/designPattern/behavioral/visitor.png"
loading="lazy"
>&lt;/p></description></item><item><title>结构型模式</title><link>https://yzlc.github.io/post/read/designpattern/structural/</link><pubDate>Mon, 15 Jul 2019 12:32:28 +0800</pubDate><guid>https://yzlc.github.io/post/read/designpattern/structural/</guid><description>&lt;h2 id="装饰模式decorator">装饰模式（Decorator）&lt;/h2>
&lt;blockquote>
&lt;p>动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/designPattern/structural/decorator.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="优点">优点&lt;/h3>
&lt;ul>
&lt;li>可以简化原有的类&lt;/li>
&lt;li>可以去除相关类中重复的装饰逻辑&lt;/li>
&lt;/ul>
&lt;h2 id="代理模式proxy">代理模式（Proxy）&lt;/h2>
&lt;blockquote>
&lt;p>为其他对象提供一种代理以控制对这个对象的访问&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/designPattern/structural/proxy.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="应用">应用&lt;/h3>
&lt;ul>
&lt;li>远程代理，也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实&lt;/li>
&lt;li>虚拟代理，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象&lt;/li>
&lt;li>安全代理，用来控制真实对象访问时的权限&lt;/li>
&lt;li>智能指引，是指当调用真实的对象时，代理处理另外一些事&lt;/li>
&lt;/ul>
&lt;h2 id="外观模式facade">外观模式（Facade）&lt;/h2>
&lt;blockquote>
&lt;p>为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/designPattern/structural/facade.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="应用-1">应用&lt;/h3>
&lt;ul>
&lt;li>设计初期阶段，层与层之间建立外观Facade&lt;/li>
&lt;li>开发阶段，增加外观Facade可以提供一个简单的接口&lt;/li>
&lt;li>维护遗留系统，提供清晰简单的接口&lt;/li>
&lt;/ul>
&lt;h2 id="适配器模式adapter">适配器模式（Adapter）&lt;/h2>
&lt;blockquote>
&lt;p>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/designPattern/structural/adapter.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="组合模式composite">组合模式（Composite）&lt;/h2>
&lt;blockquote>
&lt;p>将对象组合成树形结构以表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/designPattern/structural/composite.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="应用-2">应用&lt;/h3>
&lt;ul>
&lt;li>需求中是体现部分与整体层次的结构时，希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象&lt;/li>
&lt;/ul>
&lt;h3 id="优点-1">优点&lt;/h3>
&lt;ul>
&lt;li>定义了包含基本对象和层次结构。基本对象可以被组合成更复杂的组合对象，而这个组合对象又可以被组合，这样不断地递归下去，客户代码中，任何用到基本对象的地方都可以使用组合对象了&lt;/li>
&lt;li>用户是不用关心到底是处理一个叶节点还是处理一个组合组件，也就用不着为定义组合而写一些选择判断语句了&lt;/li>
&lt;li>组合模式让客户可以一致地使用组合结构和单个对象&lt;/li>
&lt;/ul>
&lt;h2 id="桥接模式bridge">桥接模式（Bridge）&lt;/h2>
&lt;blockquote>
&lt;p>将抽象部分与它的实现部分分离，使它们都可以独立地变化&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/designPattern/structural/bridge.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="享元模式flyweight">享元模式（Flyweight）&lt;/h2>
&lt;blockquote>
&lt;p>运用共享技术有效地支持大量细粒度的对象&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/designPattern/structural/flyweight.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="应用-3">应用&lt;/h3>
&lt;ul>
&lt;li>如果一个应用程序使用了大量的对象，而大量的这些对象造成了很大的存储开销&lt;/li>
&lt;li>对象的大多数状态可以外部状态，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象&lt;/li>
&lt;/ul></description></item><item><title>创建型模式</title><link>https://yzlc.github.io/post/read/designpattern/creational/</link><pubDate>Mon, 15 Jul 2019 11:32:28 +0800</pubDate><guid>https://yzlc.github.io/post/read/designpattern/creational/</guid><description>&lt;h2 id="简单工厂模式">简单工厂模式&lt;/h2>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/designPattern/creational/simpleFactory.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="优点">优点&lt;/h3>
&lt;ul>
&lt;li>工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖&lt;/li>
&lt;/ul>
&lt;h3 id="应用">应用&lt;/h3>
&lt;ul>
&lt;li>用反射去除switch或if，解除分支判断带来的耦合&lt;/li>
&lt;/ul>
&lt;h2 id="工厂方法模式factory-method">工厂方法模式（Factory Method）&lt;/h2>
&lt;blockquote>
&lt;p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/designPattern/creational/factoryMethod.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="vs-简单工厂">vs 简单工厂&lt;/h3>
&lt;ul>
&lt;li>把简单工厂的内部逻辑判断移到了客户端代码来进行&lt;/li>
&lt;/ul>
&lt;h2 id="原型模式prototype">原型模式（Prototype）&lt;/h2>
&lt;blockquote>
&lt;p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/designPattern/creational/prototype.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="优点-1">优点&lt;/h3>
&lt;ul>
&lt;li>一般在初始化的信息不发生变化的情况下，克隆是最好的办法。既隐藏了对象创建的细节，又对性能是大大的提高&lt;/li>
&lt;li>不用重新初始化对象，而是动态地获得对象运行时的状态&lt;/li>
&lt;/ul>
&lt;h2 id="建造者模式builder">建造者模式（Builder）&lt;/h2>
&lt;blockquote>
&lt;p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/designPattern/creational/builder.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="应用-1">应用&lt;/h3>
&lt;ul>
&lt;li>创建复杂的对象，这些对象内部构建间的建造顺序通常是稳定的，但对象内部的构建通常面临着复杂的变化&lt;/li>
&lt;li>在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用&lt;/li>
&lt;/ul>
&lt;h3 id="优点-2">优点&lt;/h3>
&lt;ul>
&lt;li>使得建造代码与表示代码分离，由于建造者隐藏了该产品是如何组装的，所以若需要改变一个产品的内部表示，只需要再定义一个具体的建造者就可以了&lt;/li>
&lt;/ul>
&lt;h2 id="抽象工厂模式abstractfactory">抽象工厂模式（AbstractFactory）&lt;/h2>
&lt;blockquote>
&lt;p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/designPattern/creational/abstractFactory.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="优点-3">优点&lt;/h3>
&lt;ul>
&lt;li>易于交换产品系列，由于具体工厂类，在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易，它只需要改变具体工厂即可使用不同的产品配置&lt;/li>
&lt;li>让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中&lt;/li>
&lt;/ul>
&lt;h3 id="缺点">缺点&lt;/h3>
&lt;ul>
&lt;li>增加产品改动太大&lt;/li>
&lt;/ul>
&lt;h3 id="改进">改进&lt;/h3>
&lt;ul>
&lt;li>简单工厂&lt;/li>
&lt;li>反射&lt;/li>
&lt;li>配置文件&lt;/li>
&lt;/ul>
&lt;h2 id="单例模式singleton">单例模式（Singleton）&lt;/h2>
&lt;blockquote>
&lt;p>保证一个类仅有一个实例，并提供一个访问它的全局访问点&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/designPattern/creational/singleton.png"
loading="lazy"
>&lt;/p></description></item><item><title>设计模式</title><link>https://yzlc.github.io/post/read/designpattern/designpattern/</link><pubDate>Mon, 15 Jul 2019 10:32:28 +0800</pubDate><guid>https://yzlc.github.io/post/read/designpattern/designpattern/</guid><description>&lt;h2 id="面向对象">面向对象&lt;/h2>
&lt;ul>
&lt;li>可维护、可复用、可扩展、灵活性好&lt;/li>
&lt;li>通过封装、继承、多态把程序的耦合度降低，用设计模式使得程序更加的灵活，容易修改，并且易于复用&lt;/li>
&lt;/ul>
&lt;h2 id="类图">类图&lt;/h2>
&lt;p>&lt;img src="https://yzlc.github.io/images/read/designPattern/uml.png"
loading="lazy"
>&lt;/p>
&lt;ul>
&lt;li>依赖：弱使用关系（方法参数）&lt;/li>
&lt;li>关联：一个类‘知道’另一个类（类属性）&lt;/li>
&lt;li>聚合：弱‘拥有’关系，A对象可以包含B对象，但B对象不是A对象的一部分（类集合属性）&lt;/li>
&lt;li>组合：强‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样（构造方法实例化）&lt;/li>
&lt;/ul>
&lt;p>强弱程度：组合 &amp;gt; 聚合 &amp;gt; 关联 &amp;gt; 依赖&lt;/p>
&lt;h2 id="原则">原则&lt;/h2>
&lt;ul>
&lt;li>单一职责：就一个类而言，应该仅有一个引起它变化的原因&lt;/li>
&lt;li>开放-封闭：软件实体（类、模块、函数等等）应该可以扩展，但是不可修改&lt;/li>
&lt;li>依赖倒转：
&lt;ul>
&lt;li>高层模块不应该依赖低层模块。两个都应该依赖抽象&lt;/li>
&lt;li>抽象不应该依赖细节。细节应该依赖抽象&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>里氏代换：子类型必须能够替换掉它们的父类型&lt;/li>
&lt;li>迪米特法则：如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用&lt;/li>
&lt;li>合成/聚合复用原则：尽量使用合成/聚合，尽量不要使用类继承&lt;/li>
&lt;/ul>
&lt;h2 id="总结">总结&lt;/h2>
&lt;h3 id="创建型模式">创建型模式&lt;/h3>
&lt;blockquote>
&lt;p>抽象工厂、建造者、工厂方法、原型、单例&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>隐藏了类的实例是如何被创建和放在一起，整个系统关于这些对象所知道的是由抽象类所定义的接口。这样，创建型模式在创建了什么、谁创建它、它是怎么被创建的，以及何时创建这些方面提供了很大的灵活性&lt;/li>
&lt;li>抽象了实例化的过程。帮助一个系统独立于如何创建、组合和表示它们的那些对象。创建型模式都会将关于该系统使用哪些具体的类的信息封装起来。允许客户用结构和功能差别很大的‘产品’对象配置一个系统。配置可以是静态的，即在编译时指定，也可以是动态的，就是运行时再指定&lt;/li>
&lt;li>通常设计应该从工厂方法开始，当需要更大的灵活性时，便向其他创建型模式演化&lt;/li>
&lt;/ul>
&lt;h3 id="结构型模式">结构型模式&lt;/h3>
&lt;blockquote>
&lt;p>怎样组装现有的类，设计它们的交互方式，从而达到实现一定的功能目的。适配器、桥接、组合、装饰、外观、享元、代理&lt;/p>
&lt;/blockquote>
&lt;h3 id="行为型模式">行为型模式&lt;/h3>
&lt;blockquote>
&lt;p>观察者、模板方法、命令、状态、职责链、解释器、中介者、访问者、策略、备忘录、迭代器&lt;/p>
&lt;/blockquote>
&lt;p>行为型模式涉及到算法和对象间职责的分配，行为模式描述了对象和类的模式，以及它们之间的通信模式，行为模式刻划了在程序运行时难以跟踪的复杂的控制流可分为行为类模式和行为对象模式&lt;/p></description></item></channel></rss>