<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>并发 on YZLC</title><link>https://yzlc.github.io/tags/%E5%B9%B6%E5%8F%91/</link><description>Recent content in 并发 on YZLC</description><generator>Hugo -- gohugo.io</generator><language>cn</language><lastBuildDate>Tue, 23 Jun 2020 13:33:33 +0800</lastBuildDate><atom:link href="https://yzlc.github.io/tags/%E5%B9%B6%E5%8F%91/index.xml" rel="self" type="application/rss+xml"/><item><title>第11章　性能与可伸缩性</title><link>https://yzlc.github.io/post/read/concurrency/11/</link><pubDate>Tue, 23 Jun 2020 13:33:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/concurrency/11/</guid><description>11.3 线程引入的开销 11.3.1 上下文切换 11.3.2 内存同步 11.3.3 阻塞 11.4 减少锁的竞争 减少锁的持有时间 降低锁的请求频率 使用带有协调机制的独占锁，这些机制允许更高的并发性</description></item><item><title>第10章　避免活跃性危险</title><link>https://yzlc.github.io/post/read/concurrency/10/</link><pubDate>Tue, 23 Jun 2020 13:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/concurrency/10/</guid><description>10.1 死锁 10.1.1 锁顺序死锁 如果所有线程以固定的顺序来获得锁，那么在程序中就不会出现锁顺序死锁问题 10.1.2 动态的锁顺序死锁 10.1.3 在协作对象之间发生的死锁 如果在持</description></item><item><title>第8章　线程池的使用</title><link>https://yzlc.github.io/post/read/concurrency/8/</link><pubDate>Tue, 23 Jun 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/concurrency/8/</guid><description>8.1 在任务与执行策略之间的隐性耦合 有些类型的任务需要明确地指定执行策略 依赖性任务 使用线程封封闭机制的任务 对响应时间敏感的任务 8.1.1 线程饥饿死锁 线程</description></item><item><title>第7章　取消与关闭</title><link>https://yzlc.github.io/post/read/concurrency/7/</link><pubDate>Mon, 22 Jun 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/concurrency/7/</guid><description>7.1 任务取消 用户请求取消 有时间限制的操作 应用程序事件 错误 关闭 7.1.1 中断 调用interrupt并不意味着立即停止目标线程正在进行的工作，而只是传递了</description></item><item><title>第6章　任务执行</title><link>https://yzlc.github.io/post/read/concurrency/6/</link><pubDate>Thu, 18 Jun 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/concurrency/6/</guid><description>6.1 在线程中执行任务 6.1.1 串行地执行任务 6.1.2 显式地为任务创建线程 6.1.3 无限制创建线程的不足 线程生命周期的开销非常高 资源消耗 稳定性 6.2 Executor框架 基</description></item><item><title>第4章　对象的组合</title><link>https://yzlc.github.io/post/read/concurrency/4/</link><pubDate>Tue, 16 Jun 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/concurrency/4/</guid><description>4.1 设计线程安全的类 在设计线程安全类的过程中，需要包含以下三个基本要素： 找出构成对象状态的所有变量。 找出约束状态变量的不变性条件。 建立对象状态</description></item><item><title>第5章　基础构建模块</title><link>https://yzlc.github.io/post/read/concurrency/5/</link><pubDate>Tue, 16 Jun 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/concurrency/5/</guid><description>5.1 同步容器类 5.1.1 同步容器类的问题 5.1.2 迭代器与ConcurrentModificationException 5.1.3 隐藏迭代器 5.2 并发容器 5.2.1 ConcurrentHashMap 只有当应用程</description></item><item><title>第2章　线程安全性</title><link>https://yzlc.github.io/post/read/concurrency/2/</link><pubDate>Mon, 15 Jun 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/concurrency/2/</guid><description>2.1 什么是线程安全性 当多个线程访问某个类时，这个类始终都能表现出正确的行为 2.2 原子性 2.2.1 竞态条件（Race Condition） 由于不恰当的执行时序</description></item><item><title>第3章　对象的共享</title><link>https://yzlc.github.io/post/read/concurrency/3/</link><pubDate>Mon, 15 Jun 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/concurrency/3/</guid><description>3.1 可见性 3.1.1 失效数据 3.1.2 非原子的64位操作 3.1.3 加锁与可见性 3.1.4 Volatile变量 当且仅当满足以下所有条件时使用： 对变量的写入操作不依赖变量的当前值</description></item></channel></rss>