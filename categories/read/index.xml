<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>read on YZLC</title><link>https://yzlc.github.io/categories/read/</link><description>Recent content in read on YZLC</description><generator>Hugo -- gohugo.io</generator><language>cn</language><lastBuildDate>Sun, 29 May 2022 15:03:33 +0800</lastBuildDate><atom:link href="https://yzlc.github.io/categories/read/index.xml" rel="self" type="application/rss+xml"/><item><title>第五章 I/O设备</title><link>https://yzlc.github.io/post/read/base/os/5/</link><pubDate>Sun, 29 May 2022 15:03:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/base/os/5/</guid><description>I/O控制方式 程序直接控制方式：CPU轮询。传输单位-字。设备-&amp;gt;CPU-&amp;gt;内存 中断驱动：CPU发出命令后做其他事。传输单位-字</description></item><item><title>第四章 文件管理</title><link>https://yzlc.github.io/post/read/base/os/4/</link><pubDate>Sat, 28 May 2022 15:08:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/base/os/4/</guid><description>文件的逻辑结构 顺序文件：可变长记录文件无法实现随机存储、定长记录、顺序结构文件可以快速检索 索引文件：索引表就是定长记录的顺序文件，若按关键字</description></item><item><title>第三章 内存</title><link>https://yzlc.github.io/post/read/base/os/3/</link><pubDate>Sat, 28 May 2022 14:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/base/os/3/</guid><description>进程运行基本原理 编译：高级语言 -&amp;gt; 机器语言 链接：把编译后的一组模块+库函数 链接在一起 装入：把链接后的装入模块 装入内存 覆盖与交换 覆盖：覆盖区、固</description></item><item><title>第二章 进程</title><link>https://yzlc.github.io/post/read/base/os/2/</link><pubDate>Tue, 10 May 2022 21:22:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/base/os/2/</guid><description>定义 PCB(系统分配用来描述进程信息)：PID(唯一标识)、UID(用户)、状态、优先级、资源分配清单(程序(数据)段指针、键盘、鼠标)、处</description></item><item><title>第一章 操作系统</title><link>https://yzlc.github.io/post/read/base/os/1/</link><pubDate>Tue, 10 May 2022 20:44:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/base/os/1/</guid><description>功能 资源管理：处理机、存储器、文件、设备 提供服务：命令、程序接口、图形界面 特征 并发：间隔发生，宏观上是同时，微观上是交替。VS 多核并行：同时</description></item><item><title>第五章 中央处理器</title><link>https://yzlc.github.io/post/read/base/organization/5/</link><pubDate>Sun, 01 May 2022 11:39:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/base/organization/5/</guid><description>CPU的功能和结构 功能：指令控制、操作控制、时间控制、数据加工、中断处理 基本结构：ALU、寄存器、中断系统、CU 运算器：算术逻辑单元(ALU</description></item><item><title>第四章 指令系统</title><link>https://yzlc.github.io/post/read/base/organization/4/</link><pubDate>Sun, 01 May 2022 10:22:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/base/organization/4/</guid><description>指令格式 操作码：定长、变长(扩展) 地址码：定长、变长。四地址-零地址 指令寻址 程序计数器PC 指令寻址 顺序寻址 跳跃寻址 数据寻址 寻址特征：隐含(程</description></item><item><title>第三章 存储系统</title><link>https://yzlc.github.io/post/read/base/organization/3/</link><pubDate>Sat, 23 Apr 2022 10:29:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/base/organization/3/</guid><description>主存 译码驱动：地址信号(地址总线) -&amp;gt; 选通信号(存储单元)。MAR(Memory Address Register)：地址寄存器。实际放CPU 存储矩阵：存储元</description></item><item><title>第二章 数据的表示和运算</title><link>https://yzlc.github.io/post/read/base/organization/2/</link><pubDate>Sat, 26 Mar 2022 13:07:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/base/organization/2/</guid><description>进制转换 十进制→K进制 按权展开相加法：通过分析十进制75位权r为10 推导出K进制→十进制 $K_{n} \times r_{n} + \dots + k_{0} \times r^{0} $ 十进制→K进制 除基取余法：尝试除</description></item><item><title>网络</title><link>https://yzlc.github.io/post/read/net/</link><pubDate>Tue, 11 Jan 2022 21:43:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/net/</guid><description>应用层 dns isp-&amp;gt;根名称服务器-&amp;gt;tld名称服务器-&amp;gt;ip http ftp 客户端 -&amp;gt; 服务端(21) 主动：服务端(20) -&amp;gt; 客户端(防火墙需</description></item><item><title>spring</title><link>https://yzlc.github.io/post/read/spring/spring/</link><pubDate>Thu, 10 Dec 2020 18:58:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/spring/spring/</guid><description>AOP 动态代理 有接口：jdk，代理接口实现类 无接口：cglib，代理子类 事务 propagation REQUIRED（default）：有则追加，无则创建 REQUIR</description></item><item><title>springIOC</title><link>https://yzlc.github.io/post/read/spring/ioc/</link><pubDate>Mon, 07 Dec 2020 22:08:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/spring/ioc/</guid><description>参考 Spring分析 请别再问Spring Bean的生命周期了！ 思想：把对象创建和调用交给spring管理，降低耦合 实现：配置解析-&amp;gt;工</description></item><item><title>5.2　单词查找树</title><link>https://yzlc.github.io/post/read/algorithms/5.2/</link><pubDate>Tue, 01 Sep 2020 13:41:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/algorithms/5.2/</guid><description>public class StringST StringST() 创建一个符号表 void put(String key, Value val) 向表中插入键值对（如果值为 null 则删除键key ） Value get(String key) 键 key 所对应的值（如果键不存在则返回 null） void delete(String key) 删除键 key</description></item><item><title>第 5 章　字符串</title><link>https://yzlc.github.io/post/read/algorithms/5/</link><pubDate>Tue, 01 Sep 2020 09:11:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/algorithms/5/</guid><description>5.1 字符串排序 5.1.1 键索引计数法 5.1.1.1 频率统计 5.1.1.2 将频率转换为索引 5.1.1.3 数据分类 5.1.1.4 回写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int N = a.length; String[] aux = new String[N]; int[] count = new int[R+1]; // 计算出现频</description></item><item><title>4.4　最短路径</title><link>https://yzlc.github.io/post/read/algorithms/4.4/</link><pubDate>Tue, 11 Aug 2020 15:53:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/algorithms/4.4/</guid><description>应用 顶点 边 地图 交叉路口 公路 网络 路由器 网络连接 任务调度 任务 优先级限制 套汇 货币 汇率 4.4.2 加权有向图的数据结构 public class DirectedEdge DirectedEdge(int v, int w, double weight) double weight() 边的权重 int from() 指出这</description></item><item><title>4.3　最小生成树</title><link>https://yzlc.github.io/post/read/algorithms/4.3/</link><pubDate>Tue, 11 Aug 2020 14:46:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/algorithms/4.3/</guid><description>权值（树中所有边的权值之和）最小的生成树 加权图：为每条边关联一个权值或是成本的图模型 图的生成树：含有其所有顶点的无环连通子图 4.3.1 原理 4.3.1.1 切分定理</description></item><item><title>4.2　有向图</title><link>https://yzlc.github.io/post/read/algorithms/4.2/</link><pubDate>Mon, 10 Aug 2020 13:24:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/algorithms/4.2/</guid><description>4.2.1 术语 由一组顶点和一组有方向的边组成的，每条有方向的边都连接着有序的一对顶点 4.2.2 有向图的数据类型 public class Digraph Digraph(int V) 创建一幅含有V个顶点但没有边的有向图</description></item><item><title>第4章　图</title><link>https://yzlc.github.io/post/read/algorithms/4.1/</link><pubDate>Fri, 07 Aug 2020 09:58:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/algorithms/4.1/</guid><description>4.1 无向图 图是由一组顶点和一组能够将两个顶点相连的边组成的 4.1.2 表示无向图的数据类型 public class Graph Graph(int V) 创建一个含有V个顶点但不含有边的图 Graph(In in) 从标准输入流 in</description></item><item><title>3.4 散列表</title><link>https://yzlc.github.io/post/read/algorithms/3.4/</link><pubDate>Wed, 05 Aug 2020 10:28:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/algorithms/3.4/</guid><description>用散列函数将被查找的键转化为数组的一个索引 处理碰撞冲突：拉链法和线性探测法 3.4.1 散列函数 3.4.1.2 正整数 除留余数法(k%M，M是素数) 3.4.1.3 浮点数 将键表示为</description></item><item><title>3.3　平衡查找树</title><link>https://yzlc.github.io/post/read/algorithms/3.3/</link><pubDate>Wed, 15 Jul 2020 15:28:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/algorithms/3.3/</guid><description>3.3.1 2-3 查找树 2-结点，含有一个键（及其对应的值）和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。 3-</description></item><item><title>3.2　二叉查找树</title><link>https://yzlc.github.io/post/read/algorithms/3.2/</link><pubDate>Wed, 15 Jul 2020 14:28:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/algorithms/3.2/</guid><description>一棵二叉查找树 （BST）是一棵二叉树，其中每个结点都含有一个Comparable 的键（以及相关联的值）且每个结点的键都大于其左子树中 的任意结</description></item><item><title>第3章　查找</title><link>https://yzlc.github.io/post/read/algorithms/3.1/</link><pubDate>Wed, 15 Jul 2020 13:28:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/algorithms/3.1/</guid><description>3.1 符号表 符号表是一种存储键值对的数据结构，支持两种操作：插入（put），即将一组新的键值对存入表中；查找 （get），即根据给定的键得到相应的</description></item><item><title>第2章　排序</title><link>https://yzlc.github.io/post/read/algorithms/2/</link><pubDate>Tue, 07 Jul 2020 10:27:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/algorithms/2/</guid><description>2.1 初级排序算法 2.1.2 选择排序 不断地选择剩余元素之中的最小者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Selection { public static boolean less(Comparable v, Comparable w) { return v.compareTo(w) &amp;lt; 0; } private static void exch(Comparable[] a, int i, int j) { Comparable</description></item><item><title>第1章　基础</title><link>https://yzlc.github.io/post/read/algorithms/1/</link><pubDate>Thu, 02 Jul 2020 14:01:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/algorithms/1/</guid><description>1.3 背包、队列和栈 1.3.1 API 1.3.1.4 背包 不支持从中删除元素的集合数据类型——它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素 1.3.1.5 先进先出队列 先进先出队</description></item><item><title>read</title><link>https://yzlc.github.io/post/read/read/</link><pubDate>Wed, 24 Jun 2020 09:13:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/read/</guid><description>基础 《深入理解计算机系统》 《tcp/ip详解》 《数据结构与算法》 《快乐的Linux命令行》 原书 王道 计算机组成原理 操作系统 设计 《Java编程思</description></item><item><title>第11章　性能与可伸缩性</title><link>https://yzlc.github.io/post/read/concurrency/11/</link><pubDate>Tue, 23 Jun 2020 13:33:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/concurrency/11/</guid><description>11.3 线程引入的开销 11.3.1 上下文切换 11.3.2 内存同步 11.3.3 阻塞 11.4 减少锁的竞争 减少锁的持有时间 降低锁的请求频率 使用带有协调机制的独占锁，这些机制允许更高的并发性</description></item><item><title>第10章　避免活跃性危险</title><link>https://yzlc.github.io/post/read/concurrency/10/</link><pubDate>Tue, 23 Jun 2020 13:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/concurrency/10/</guid><description>10.1 死锁 10.1.1 锁顺序死锁 如果所有线程以固定的顺序来获得锁，那么在程序中就不会出现锁顺序死锁问题 10.1.2 动态的锁顺序死锁 10.1.3 在协作对象之间发生的死锁 如果在持</description></item><item><title>第8章　线程池的使用</title><link>https://yzlc.github.io/post/read/concurrency/8/</link><pubDate>Tue, 23 Jun 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/concurrency/8/</guid><description>8.1 在任务与执行策略之间的隐性耦合 有些类型的任务需要明确地指定执行策略 依赖性任务 使用线程封封闭机制的任务 对响应时间敏感的任务 8.1.1 线程饥饿死锁 线程</description></item><item><title>第7章　取消与关闭</title><link>https://yzlc.github.io/post/read/concurrency/7/</link><pubDate>Mon, 22 Jun 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/concurrency/7/</guid><description>7.1 任务取消 用户请求取消 有时间限制的操作 应用程序事件 错误 关闭 7.1.1 中断 调用interrupt并不意味着立即停止目标线程正在进行的工作，而只是传递了</description></item><item><title>第6章　任务执行</title><link>https://yzlc.github.io/post/read/concurrency/6/</link><pubDate>Thu, 18 Jun 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/concurrency/6/</guid><description>6.1 在线程中执行任务 6.1.1 串行地执行任务 6.1.2 显式地为任务创建线程 6.1.3 无限制创建线程的不足 线程生命周期的开销非常高 资源消耗 稳定性 6.2 Executor框架 基</description></item><item><title>第4章　对象的组合</title><link>https://yzlc.github.io/post/read/concurrency/4/</link><pubDate>Tue, 16 Jun 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/concurrency/4/</guid><description>4.1 设计线程安全的类 在设计线程安全类的过程中，需要包含以下三个基本要素： 找出构成对象状态的所有变量。 找出约束状态变量的不变性条件。 建立对象状态</description></item><item><title>第5章　基础构建模块</title><link>https://yzlc.github.io/post/read/concurrency/5/</link><pubDate>Tue, 16 Jun 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/concurrency/5/</guid><description>5.1 同步容器类 5.1.1 同步容器类的问题 5.1.2 迭代器与ConcurrentModificationException 5.1.3 隐藏迭代器 5.2 并发容器 5.2.1 ConcurrentHashMap 只有当应用程</description></item><item><title>第2章　线程安全性</title><link>https://yzlc.github.io/post/read/concurrency/2/</link><pubDate>Mon, 15 Jun 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/concurrency/2/</guid><description>2.1 什么是线程安全性 当多个线程访问某个类时，这个类始终都能表现出正确的行为 2.2 原子性 2.2.1 竞态条件（Race Condition） 由于不恰当的执行时序</description></item><item><title>第3章　对象的共享</title><link>https://yzlc.github.io/post/read/concurrency/3/</link><pubDate>Mon, 15 Jun 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/concurrency/3/</guid><description>3.1 可见性 3.1.1 失效数据 3.1.2 非原子的64位操作 3.1.3 加锁与可见性 3.1.4 Volatile变量 当且仅当满足以下所有条件时使用： 对变量的写入操作不依赖变量的当前值</description></item><item><title>第12章　Java内存模型与线程</title><link>https://yzlc.github.io/post/read/jvm/12/</link><pubDate>Wed, 03 Jun 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/jvm/12/</guid><description>12.1 概述 每秒事务处理数（Transactions Per Second，TPS） 12.3 Java内存模型 定义程序中各种变量的访问规则，即关注在虚拟机中把变量</description></item><item><title>第13章　线程安全与锁优化</title><link>https://yzlc.github.io/post/read/jvm/13/</link><pubDate>Wed, 03 Jun 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/jvm/13/</guid><description>13.2 线程安全 13.2.1 Java语言中的线程安全 不可变 基本数据类型：在定义时使用final关键字修饰 对象：需要保证其行为不会对其状态产生任何影响(Str</description></item><item><title>第11章　后端编译与优化</title><link>https://yzlc.github.io/post/read/jvm/11/</link><pubDate>Tue, 02 Jun 2020 11:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/jvm/11/</guid><description>11.2 即时编译器 Java程序最初都是通过解释器（Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代</description></item><item><title>第10章　前端编译与优化</title><link>https://yzlc.github.io/post/read/jvm/10/</link><pubDate>Tue, 02 Jun 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/jvm/10/</guid><description>10.2 Javac编译器 10.2.1 Javac的源码与调试 下载 10.2.2 解析与填充符号表 词法、语法分析 词法分析: 将源代码的字符流转变为标记（Token）集合的过程，</description></item><item><title>第8章　虚拟机字节码执行引擎</title><link>https://yzlc.github.io/post/read/jvm/8/</link><pubDate>Mon, 01 Jun 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/jvm/8/</guid><description>8.2 运行时栈帧结构 Java虚拟机以方法作为最基本的执行单元 栈帧（Stack Frame）:虚拟机进行方法调用和方法执行背后的数据结构，也是虚拟机</description></item><item><title>第7章　虚拟机类加载机制</title><link>https://yzlc.github.io/post/read/jvm/7/</link><pubDate>Wed, 27 May 2020 11:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/jvm/7/</guid><description>7.2 类加载的时机 加载（Loading）-&amp;gt;连接（Linking）[验证（Verification）-&amp;gt;准备（Preparation</description></item><item><title>6.4　字节码指令简介</title><link>https://yzlc.github.io/post/read/jvm/6.4/</link><pubDate>Wed, 27 May 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/jvm/6.4/</guid><description>6.4.1 字节码与数据类型 编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为相应的int类型数据，将bo</description></item><item><title>6.3　Class类文件的结构</title><link>https://yzlc.github.io/post/read/jvm/6.3/</link><pubDate>Thu, 14 May 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/jvm/6.3/</guid><description>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符。当遇到需要占用8个</description></item><item><title>第4章　虚拟机性能监控、故障处理工具</title><link>https://yzlc.github.io/post/read/jvm/4/</link><pubDate>Tue, 12 May 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/jvm/4/</guid><description>4.2 基础故障处理工具 4.2.1 jps（JVM Process Status Tool）：虚拟机进程状况工具 命令格式：jps [ options ] [ hostid ] 选项 作用 -q 只输出LVMID,省略主类的名称 -m</description></item><item><title>第3章　垃圾收集器</title><link>https://yzlc.github.io/post/read/jvm/3.5/</link><pubDate>Sat, 09 May 2020 11:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/jvm/3.5/</guid><description>3.5 经典垃圾收集器 3.5.1 Serial收集器 单线程,HotSpot虚拟机运行在客户端模式下的默认新生代收集器，对于内存资源受限的环境，它是所有收集器</description></item><item><title>第3章　内存分配策略</title><link>https://yzlc.github.io/post/read/jvm/3/</link><pubDate>Sat, 09 May 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/jvm/3/</guid><description>3.2 对象已死？ 3.2.1 引用计数算法 在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为</description></item><item><title>第2章　Java内存区域与内存溢出异常</title><link>https://yzlc.github.io/post/read/jvm/2/</link><pubDate>Fri, 08 May 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/jvm/2/</guid><description>2.2 运行时数据区域 2.2.1 程序计数器（Program Counter Register） 字节码的行号指示器，程序控制流的指示器（分支、循环、跳转、异常处理、线程恢复</description></item><item><title>第1章　走近Java</title><link>https://yzlc.github.io/post/read/jvm/1/</link><pubDate>Thu, 30 Apr 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/jvm/1/</guid><description>1.6 实战:自己编译JDK 1.6.1 获取源码 下载 -&amp;gt; browse -&amp;gt; zip 1.6.3 构建编译环境(Ubuntu) 工具 命令 GCC sudo apt-get install build-essential FreeType sudo apt-get install libfreetype6-dev CUPS sudo apt-get install libcups2-dev X11 sudo apt-get install libx11-dev libxext-dev libxrender-dev libxrandr-dev libxtst-dev libxt-dev ALSA sudo apt-get install</description></item><item><title>第5章 优化程序性能</title><link>https://yzlc.github.io/post/read/csapp/5/</link><pubDate>Wed, 29 Apr 2020 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/csapp/5/</guid><description>5.1 优化编译器的能力和局限性 5.2 表示程序性能 CPE(Cycles Per Element):每元素的周期数 循环展开(loop unrolling) 举例:前置和,每次迭代计算两个元素 5.3 程序示例</description></item><item><title>3.7 过程</title><link>https://yzlc.github.io/post/read/csapp/3.7/</link><pubDate>Tue, 31 Dec 2019 12:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/csapp/3.7/</guid><description>3.7 过程 3.7.1 运行时栈 x86-64的栈向低地址方向增长，栈指针%rsp指向栈顶元素。减小栈指针分配空间，增加栈指针释放空间 当x86-64过程需要的</description></item><item><title>3.6 控制</title><link>https://yzlc.github.io/post/read/csapp/3.6/</link><pubDate>Tue, 31 Dec 2019 11:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/csapp/3.6/</guid><description>3.6 控制 3.6.1 条件码 CF：进位。无符号溢出 ZF：零 SF：符号。负数 OF：溢出。补码溢出 指令 基于 描述 CMP S1，S2 S2-S1 比较 TEST S1，S2 S1&amp;amp;S2 测试 3.6.2 访问条件码</description></item><item><title>第3章 程序的机器级表示</title><link>https://yzlc.github.io/post/read/csapp/3/</link><pubDate>Tue, 31 Dec 2019 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/csapp/3/</guid><description>3.2 程序编码 3.2.1 机器级代码 程序计数器（PC，在x86-64中用%rip表示）：给出要执行的下一条指令在内存中的地址 整数寄存器：包含16个命名位置</description></item><item><title>第2章 信息的表示和处理</title><link>https://yzlc.github.io/post/read/csapp/2/</link><pubDate>Mon, 30 Dec 2019 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/csapp/2/</guid><description>2.1 信息存储 2.1.1 十六进制表示法 二进制 (i+4j,{i∈[0,3],j个0})&amp;lt;——&amp;gt;(4位一拆) 十六进制 (除16)&amp;lt;——&amp;gt</description></item><item><title>第1章 计算机系统漫游</title><link>https://yzlc.github.io/post/read/csapp/1/</link><pubDate>Sun, 29 Dec 2019 10:32:28 +0800</pubDate><guid>https://yzlc.github.io/post/read/csapp/1/</guid><description>1.9.1 Amdahl&amp;rsquo;s law（阿姆达尔定律） 要想显著加速整个系统，必须提升全系统中相当大的部分的速度 若系统执行某应用程序需要时间为$T_{old}$。 假设系统</description></item><item><title>effective java</title><link>https://yzlc.github.io/post/read/effectivejava/effectivejava/</link><pubDate>Mon, 26 Aug 2019 10:32:28 +0800</pubDate><guid>https://yzlc.github.io/post/read/effectivejava/effectivejava/</guid><description>1. 考虑使用静态工厂方法替代构造方法 1 2 3 public static Boolean valueOf(boolean b) { return b ? Boolean.TRUE : Boolean.FALSE; } 优点 有名字(BigInteger.probablePrime) 不用每次调用</description></item><item><title>行为型模式</title><link>https://yzlc.github.io/post/read/designpattern/behavioral/</link><pubDate>Mon, 15 Jul 2019 13:32:28 +0800</pubDate><guid>https://yzlc.github.io/post/read/designpattern/behavioral/</guid><description>策略模式（Strategy） 定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。 优点 以相同的</description></item><item><title>结构型模式</title><link>https://yzlc.github.io/post/read/designpattern/structural/</link><pubDate>Mon, 15 Jul 2019 12:32:28 +0800</pubDate><guid>https://yzlc.github.io/post/read/designpattern/structural/</guid><description>装饰模式（Decorator） 动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活 优点 可以简化原有的类 可以去除相关</description></item><item><title>创建型模式</title><link>https://yzlc.github.io/post/read/designpattern/creational/</link><pubDate>Mon, 15 Jul 2019 11:32:28 +0800</pubDate><guid>https://yzlc.github.io/post/read/designpattern/creational/</guid><description>简单工厂模式 优点 工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖 应用 用反射去除s</description></item><item><title>设计模式</title><link>https://yzlc.github.io/post/read/designpattern/designpattern/</link><pubDate>Mon, 15 Jul 2019 10:32:28 +0800</pubDate><guid>https://yzlc.github.io/post/read/designpattern/designpattern/</guid><description>面向对象 可维护、可复用、可扩展、灵活性好 通过封装、继承、多态把程序的耦合度降低，用设计模式使得程序更加的灵活，容易修改，并且易于复用 类图 依赖</description></item><item><title>linux - shell</title><link>https://yzlc.github.io/post/read/linux/shell/</link><pubDate>Sat, 01 Jun 2019 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/linux/shell/</guid><description>shell环境 set shell或环境变量 printenv 环境变量 echo 查看变量内容 alias 查看别名 有趣的环境变量 DISPLAY 如果你正在运行图形界面环境，那么这个变量就是你显示器的</description></item><item><title>linux - 键盘高级操作技巧</title><link>https://yzlc.github.io/post/read/linux/key/</link><pubDate>Sat, 01 Jun 2019 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/linux/key/</guid><description>移动光标 Ctrl-a 移动光标到行首 Ctrl-e 移动光标到行尾 Ctrl-f 光标前移一个字符；和右箭头作用一样 Ctrl-b 光标后移一个字符；和左箭头作用一样 Alt-f 光标前移一个字 Alt-b 光标后移一</description></item><item><title>linux - 进程</title><link>https://yzlc.github.io/post/read/linux/process/</link><pubDate>Sat, 01 Jun 2019 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/linux/process/</guid><description>ps ps -ef|grep xx ps x 所有进程 ps aux 用户进程 VSZ 虚拟内存大小 RSS 进程占用的物理内存的大小，以千字节为单位。 START 进程启动的时间。若它的值超过24小时，则用天表示</description></item><item><title>linux - 权限</title><link>https://yzlc.github.io/post/read/linux/auth/</link><pubDate>Sat, 01 Jun 2019 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/linux/auth/</guid><description>拥有者、组成员和其他人 id 查看身份 文件类型 - 文件 d 目录 l 符号链接。注意对于符号链接文件，剩余的文件属性总是rwxrwxrwx，而且都是 虚拟值。</description></item><item><title>linux - 软件包管理</title><link>https://yzlc.github.io/post/read/linux/pkgmgr/</link><pubDate>Sat, 01 Jun 2019 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/linux/pkgmgr/</guid><description>打包系统 Debian Style (.deb) Debian, Ubuntu, Xandros, Linspire Red Hat Style (.rpm) Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE, Mandriva, PCLinuxOS 包管理工具 发行版 底层工具 上层工具 Debian-Style dpkg apt-get, aptitude Fedora, Red Hat Enterprise Linux, CentOS rpm yum 底层工具用来处理这些任务，比方说安装</description></item><item><title>linux - 使用命令</title><link>https://yzlc.github.io/post/read/linux/cmd/</link><pubDate>Sat, 01 Jun 2019 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/linux/cmd/</guid><description>使用命令 type 显示命令的类型 which 显示一个可执行程序的位置 help 得到 shell 内建命令的帮助文档 --help 显示用法信息 apropos（man -k） 显示适当的命令 whatis 显示简</description></item><item><title>linux - 探究操作系统</title><link>https://yzlc.github.io/post/read/linux/filedir/</link><pubDate>Sat, 01 Jun 2019 10:32:33 +0800</pubDate><guid>https://yzlc.github.io/post/read/linux/filedir/</guid><description>less Page UP or b 向上翻页 Page Down or space 向下翻页 UP Arrow 向上翻一行 Down Arrow 向下翻一行 G 移动到最后 1G or g 移动到开头 /characters 向前查找 n 向前查找下一个出现的字符串，这个字符串</description></item></channel></rss>